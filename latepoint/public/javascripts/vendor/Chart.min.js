"use strict";function _typeof(t){return(_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function t(e){return typeof e}:function t(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(t)}
/*!
 * Chart.js
 * http://chartjs.org/
 * Version: 2.7.3
 *
 * Copyright 2018 Chart.js Contributors
 * Released under the MIT license
 * https://github.com/chartjs/Chart.js/blob/master/LICENSE.md
 */
/*!
 * Chart.js
 * http://chartjs.org/
 * Version: 2.7.3
 *
 * Copyright 2018 Chart.js Contributors
 * Released under the MIT license
 * https://github.com/chartjs/Chart.js/blob/master/LICENSE.md
 */
!function(t){if("object"===("undefined"==typeof exports?"undefined":_typeof(exports))&&"undefined"!=typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var e;(e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).Chart=t()}}(function(){var t,e,n;return function(){function d(o,r,l){function s(n,t){if(!r[n]){if(!o[n]){var e="function"==typeof require&&require;if(!t&&e)return e(n,!0);if(u)return u(n,!0);var i=new Error("Cannot find module '"+n+"'");throw i.code="MODULE_NOT_FOUND",i}var a=r[n]={exports:{}};o[n][0].call(a.exports,function(t){var e;return s(o[n][1][t]||t)},a,a.exports,d,o,r,l)}return r[n].exports}for(var u="function"==typeof require&&require,t=0;t<l.length;t++)s(l[t]);return s}return d}()({1:[function(t,e,n){},{}],2:[function(t,e,n){function i(t){if(t){var e=/^#([a-fA-F0-9]{3})$/i,n=/^#([a-fA-F0-9]{6})$/i,i=/^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,a=/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,o=/(\w+)/,r=[0,0,0],l=1,s=t.match(e);if(s){s=s[1];for(var u=0;u<r.length;u++)r[u]=parseInt(s[u]+s[u],16)}else if(s=t.match(n)){s=s[1];for(var u=0;u<r.length;u++)r[u]=parseInt(s.slice(2*u,2*u+2),16)}else if(s=t.match(i)){for(var u=0;u<r.length;u++)r[u]=parseInt(s[u+1]);l=parseFloat(s[4])}else if(s=t.match(a)){for(var u=0;u<r.length;u++)r[u]=Math.round(2.55*parseFloat(s[u+1]));l=parseFloat(s[4])}else if(s=t.match(o)){if("transparent"==s[1])return[0,0,0,0];if(!(r=y[s[1]]))return}for(var u=0;u<r.length;u++)r[u]=b(r[u],0,255);return l=l||0==l?b(l,0,1):1,r[3]=l,r}}function a(t){if(t){var e=/^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/,n=t.match(e);if(n){var i=parseFloat(n[4]),a,o,r,l;return[b(parseInt(n[1]),0,360),b(parseFloat(n[2]),0,100),b(parseFloat(n[3]),0,100),b(isNaN(i)?1:i,0,1)]}}}function o(t){if(t){var e=/^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/,n=t.match(e);if(n){var i=parseFloat(n[4]),a,o,r,l;return[b(parseInt(n[1]),0,360),b(parseFloat(n[2]),0,100),b(parseFloat(n[3]),0,100),b(isNaN(i)?1:i,0,1)]}}}function r(t){var e=i(t);return e&&e.slice(0,3)}function l(t){var e=a(t);return e&&e.slice(0,3)}function s(t){var e=i(t);return e?e[3]:(e=a(t))?e[3]:(e=o(t))?e[3]:void 0}// generators
function u(t){return"#"+x(t[0])+x(t[1])+x(t[2])}function d(t,e){return e<1||t[3]&&t[3]<1?c(t,e):"rgb("+t[0]+", "+t[1]+", "+t[2]+")"}function c(t,e){return void 0===e&&(e=void 0!==t[3]?t[3]:1),"rgba("+t[0]+", "+t[1]+", "+t[2]+", "+e+")"}function h(t,e){return e<1||t[3]&&t[3]<1?f(t,e):"rgb("+Math.round(t[0]/255*100)+"%, "+Math.round(t[1]/255*100)+"%, "+Math.round(t[2]/255*100)+"%)";var n,i,a}function f(t,e){var n,i,a;return"rgba("+Math.round(t[0]/255*100)+"%, "+Math.round(t[1]/255*100)+"%, "+Math.round(t[2]/255*100)+"%, "+(e||t[3]||1)+")"}function g(t,e){return e<1||t[3]&&t[3]<1?p(t,e):"hsl("+t[0]+", "+t[1]+"%, "+t[2]+"%)"}function p(t,e){return void 0===e&&(e=void 0!==t[3]?t[3]:1),"hsla("+t[0]+", "+t[1]+"%, "+t[2]+"%, "+e+")"}// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
function m(t,e){return void 0===e&&(e=void 0!==t[3]?t[3]:1),"hwb("+t[0]+", "+t[1]+"%, "+t[2]+"%"+(void 0!==e&&1!==e?", "+e:"")+")"}function v(t){return k[t.slice(0,3)]}// helpers
function b(t,e,n){return Math.min(Math.max(e,t),n)}function x(t){var e=t.toString(16).toUpperCase();return e.length<2?"0"+e:e}//create a list of reverse color names
/* MIT license */
var y=t(6);e.exports={getRgba:i,getHsla:a,getRgb:r,getHsl:l,getHwb:o,getAlpha:s,hexString:u,rgbString:d,rgbaString:c,percentString:h,percentaString:f,hslString:g,hslaString:p,hwbString:m,keyword:v};var k={};for(var w in y)k[y[w]]=w},{6:6}],3:[function(t,e,n){
/* MIT license */
var d=t(5),i=t(2),l=function t(e){return e instanceof t?e:this instanceof t?(this.valid=!1,this.values={rgb:[0,0,0],hsl:[0,0,0],hsv:[0,0,0],hwb:[0,0,0],cmyk:[0,0,0,0],alpha:1},void("string"==typeof e?(n=i.getRgba(e))?this.setValues("rgb",n):(n=i.getHsla(e))?this.setValues("hsl",n):(n=i.getHwb(e))&&this.setValues("hwb",n):"object"===_typeof(e)&&(void 0!==(n=e).r||void 0!==n.red?this.setValues("rgb",n):void 0!==n.l||void 0!==n.lightness?this.setValues("hsl",n):void 0!==n.v||void 0!==n.value?this.setValues("hsv",n):void 0!==n.w||void 0!==n.whiteness?this.setValues("hwb",n):void 0===n.c&&void 0===n.cyan||this.setValues("cmyk",n)))):new t(e);// parse Color() argument
var n};l.prototype={isValid:function t(){return this.valid},rgb:function t(){return this.setSpace("rgb",arguments)},hsl:function t(){return this.setSpace("hsl",arguments)},hsv:function t(){return this.setSpace("hsv",arguments)},hwb:function t(){return this.setSpace("hwb",arguments)},cmyk:function t(){return this.setSpace("cmyk",arguments)},rgbArray:function t(){return this.values.rgb},hslArray:function t(){return this.values.hsl},hsvArray:function t(){return this.values.hsv},hwbArray:function t(){var e=this.values;return 1!==e.alpha?e.hwb.concat([e.alpha]):e.hwb},cmykArray:function t(){return this.values.cmyk},rgbaArray:function t(){var e=this.values;return e.rgb.concat([e.alpha])},hslaArray:function t(){var e=this.values;return e.hsl.concat([e.alpha])},alpha:function t(e){return void 0===e?this.values.alpha:(this.setValues("alpha",e),this)},red:function t(e){return this.setChannel("rgb",0,e)},green:function t(e){return this.setChannel("rgb",1,e)},blue:function t(e){return this.setChannel("rgb",2,e)},hue:function t(e){return e&&(e=(e%=360)<0?360+e:e),this.setChannel("hsl",0,e)},saturation:function t(e){return this.setChannel("hsl",1,e)},lightness:function t(e){return this.setChannel("hsl",2,e)},saturationv:function t(e){return this.setChannel("hsv",1,e)},whiteness:function t(e){return this.setChannel("hwb",1,e)},blackness:function t(e){return this.setChannel("hwb",2,e)},value:function t(e){return this.setChannel("hsv",2,e)},cyan:function t(e){return this.setChannel("cmyk",0,e)},magenta:function t(e){return this.setChannel("cmyk",1,e)},yellow:function t(e){return this.setChannel("cmyk",2,e)},black:function t(e){return this.setChannel("cmyk",3,e)},hexString:function t(){return i.hexString(this.values.rgb)},rgbString:function t(){return i.rgbString(this.values.rgb,this.values.alpha)},rgbaString:function t(){return i.rgbaString(this.values.rgb,this.values.alpha)},percentString:function t(){return i.percentString(this.values.rgb,this.values.alpha)},hslString:function t(){return i.hslString(this.values.hsl,this.values.alpha)},hslaString:function t(){return i.hslaString(this.values.hsl,this.values.alpha)},hwbString:function t(){return i.hwbString(this.values.hwb,this.values.alpha)},keyword:function t(){return i.keyword(this.values.rgb,this.values.alpha)},rgbNumber:function t(){var e=this.values.rgb;return e[0]<<16|e[1]<<8|e[2]},luminosity:function t(){for(
// http://www.w3.org/TR/WCAG20/#relativeluminancedef
var e=this.values.rgb,n=[],i=0;i<e.length;i++){var a=e[i]/255;n[i]=a<=.03928?a/12.92:Math.pow((a+.055)/1.055,2.4)}return.2126*n[0]+.7152*n[1]+.0722*n[2]},contrast:function t(e){
// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
var n=this.luminosity(),i=e.luminosity();return i<n?(n+.05)/(i+.05):(i+.05)/(n+.05)},level:function t(e){var n=this.contrast(e);return 7.1<=n?"AAA":4.5<=n?"AA":""},dark:function t(){
// YIQ equation from http://24ways.org/2010/calculating-color-contrast
var e=this.values.rgb,n;return(299*e[0]+587*e[1]+114*e[2])/1e3<128},light:function t(){return!this.dark()},negate:function t(){for(var e=[],n=0;n<3;n++)e[n]=255-this.values.rgb[n];return this.setValues("rgb",e),this},lighten:function t(e){var n=this.values.hsl;return n[2]+=n[2]*e,this.setValues("hsl",n),this},darken:function t(e){var n=this.values.hsl;return n[2]-=n[2]*e,this.setValues("hsl",n),this},saturate:function t(e){var n=this.values.hsl;return n[1]+=n[1]*e,this.setValues("hsl",n),this},desaturate:function t(e){var n=this.values.hsl;return n[1]-=n[1]*e,this.setValues("hsl",n),this},whiten:function t(e){var n=this.values.hwb;return n[1]+=n[1]*e,this.setValues("hwb",n),this},blacken:function t(e){var n=this.values.hwb;return n[2]+=n[2]*e,this.setValues("hwb",n),this},greyscale:function t(){var e=this.values.rgb,n=.3*e[0]+.59*e[1]+.11*e[2];// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
return this.setValues("rgb",[n,n,n]),this},clearer:function t(e){var n=this.values.alpha;return this.setValues("alpha",n-n*e),this},opaquer:function t(e){var n=this.values.alpha;return this.setValues("alpha",n+n*e),this},rotate:function t(e){var n=this.values.hsl,i=(n[0]+e)%360;return n[0]=i<0?360+i:i,this.setValues("hsl",n),this},
/**
         * Ported from sass implementation in C
         * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
         */
mix:function t(e,n){var i=this,a=e,o=void 0===n?.5:n,r=2*o-1,l=i.alpha()-a.alpha(),s=((r*l==-1?r:(r+l)/(1+r*l))+1)/2,u=1-s;return this.rgb(s*i.red()+u*a.red(),s*i.green()+u*a.green(),s*i.blue()+u*a.blue()).alpha(i.alpha()*o+a.alpha()*(1-o))},toJSON:function t(){return this.rgb()},clone:function t(){
// NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,
// making the final build way to big to embed in Chart.js. So let's do it manually,
// assuming that values to clone are 1 dimension arrays containing only numbers,
// except 'alpha' which is a number.
var e=new l,n=this.values,i=e.values,a,o;for(var r in n)n.hasOwnProperty(r)&&(a=n[r],"[object Array]"===(o={}.toString.call(a))?i[r]=a.slice(0):"[object Number]"===o?i[r]=a:console.error("unexpected color value:",a));return e}},l.prototype.spaces={rgb:["red","green","blue"],hsl:["hue","saturation","lightness"],hsv:["hue","saturation","value"],hwb:["hue","whiteness","blackness"],cmyk:["cyan","magenta","yellow","black"]},l.prototype.maxes={rgb:[255,255,255],hsl:[360,100,100],hsv:[360,100,100],hwb:[360,100,100],cmyk:[100,100,100,100]},l.prototype.getValues=function(t){for(var e=this.values,n={},i=0;i<t.length;i++)n[t.charAt(i)]=e[t][i];// {r: 255, g: 255, b: 255, a: 0.4}
return 1!==e.alpha&&(n.a=e.alpha),n},l.prototype.setValues=function(t,e){var n=this.values,i=this.spaces,a=this.maxes,o=1,r,l;if(this.valid=!0,"alpha"===t)o=e;else if(e.length)
// [10, 10, 10]
n[t]=e.slice(0,t.length),o=e[t.length];else if(void 0!==e[t.charAt(0)]){
// {r: 10, g: 10, b: 10}
for(r=0;r<t.length;r++)n[t][r]=e[t.charAt(r)];o=e.a}else if(void 0!==e[i[t][0]]){
// {red: 10, green: 10, blue: 10}
var s=i[t];for(r=0;r<t.length;r++)n[t][r]=e[s[r]];o=e.alpha}if(n.alpha=Math.max(0,Math.min(1,void 0===o?n.alpha:o)),"alpha"===t)return!1;// cap values of the space prior converting all values
for(r=0;r<t.length;r++)l=Math.max(0,Math.min(a[t][r],n[t][r])),n[t][r]=Math.round(l);// convert to all the other color spaces
for(var u in i)u!==t&&(n[u]=d[t][u](n[t]));return!0},l.prototype.setSpace=function(t,e){var n=e[0];return void 0===n?this.getValues(t):(// color.rgb(10, 10, 10)
"number"==typeof n&&(n=Array.prototype.slice.call(e)),this.setValues(t,n),this)},l.prototype.setChannel=function(t,e,n){var i=this.values[t];return void 0===n?i[e]:(n===i[e]||(// color.red(100)
i[e]=n,this.setValues(t,i)),this)},"undefined"!=typeof window&&(window.Chart=window.Chart||{},window.Chart.Color=l,void 0===window.Color&&(
// maintain backward compatibility ONLY if no other Color lib has been defined
window.Color=l)),e.exports=l},{2:2,5:5}],4:[function(t,e,n){function l(t){var e=t[0]/255,n=t[1]/255,i=t[2]/255,a=Math.min(e,n,i),o=Math.max(e,n,i),r=o-a,l,s,u;return o==a?l=0:e==o?l=(n-i)/r:n==o?l=2+(i-e)/r:i==o&&(l=4+(e-n)/r),(l=Math.min(60*l,360))<0&&(l+=360),u=(a+o)/2,[l,100*(s=o==a?0:u<=.5?r/(o+a):r/(2-o-a)),100*u]}function i(t){var e=t[0],n=t[1],i=t[2],a=Math.min(e,n,i),o=Math.max(e,n,i),r=o-a,l,s,u;return s=0==o?0:r/o*1e3/10,o==a?l=0:e==o?l=(n-i)/r:n==o?l=2+(i-e)/r:i==o&&(l=4+(e-n)/r),(l=Math.min(60*l,360))<0&&(l+=360),[l,s,u=o/255*1e3/10]}function a(t){var e=t[0],n=t[1],i=t[2],a,o,i;return[l(t)[0],100*(1/255*Math.min(e,Math.min(n,i))),100*(i=1-1/255*Math.max(e,Math.max(n,i)))]}function o(t){var e=t[0]/255,n=t[1]/255,i=t[2]/255,a,o,r,l;return[100*(a=(1-e-(l=Math.min(1-e,1-n,1-i)))/(1-l)||0),100*(o=(1-n-l)/(1-l)||0),100*(r=(1-i-l)/(1-l)||0),100*l]}function s(t){return Z[JSON.stringify(t)]}function u(t){var e=t[0]/255,n=t[1]/255,i=t[2]/255,a,o,r;// assume sRGB
return[100*(.4124*(e=.04045<e?Math.pow((e+.055)/1.055,2.4):e/12.92)+.3576*(n=.04045<n?Math.pow((n+.055)/1.055,2.4):n/12.92)+.1805*(i=.04045<i?Math.pow((i+.055)/1.055,2.4):i/12.92)),100*(.2126*e+.7152*n+.0722*i),100*(.0193*e+.1192*n+.9505*i)]}function d(t){var e=u(t),n=e[0],i=e[1],a=e[2],o,r,l;return i/=100,a/=108.883,n=.008856<(n/=95.047)?Math.pow(n,1/3):7.787*n+16/116,[o=116*(i=.008856<i?Math.pow(i,1/3):7.787*i+16/116)-16,r=500*(n-i),l=200*(i-(a=.008856<a?Math.pow(a,1/3):7.787*a+16/116))]}function c(t){return B(d(t))}function h(t){var e=t[0]/360,n=t[1]/100,i=t[2]/100,a,o,r,l,s;if(0==n)return[s=255*i,s,s];a=2*i-(o=i<.5?i*(1+n):i+n-i*n),l=[0,0,0];for(var u=0;u<3;u++)(r=e+1/3*-(u-1))<0&&r++,1<r&&r--,s=6*r<1?a+6*(o-a)*r:2*r<1?o:3*r<2?a+(o-a)*(2/3-r)*6:a,l[u]=255*s;return l}function f(t){var e=t[0],n=t[1]/100,i=t[2]/100,a,o;return 0===i?[0,0,0]:[e,100*(a=2*(n*=(i*=2)<=1?i:2-i)/(i+n)),100*(o=(i+n)/2)]}function p(t){return a(h(t))}function m(t){return o(h(t))}function v(t){return s(h(t))}function x(t){var e=t[0]/60,n=t[1]/100,i=t[2]/100,a=Math.floor(e)%6,o=e-Math.floor(e),r=255*i*(1-n),l=255*i*(1-n*o),s=255*i*(1-n*(1-o)),i=255*i;switch(a){case 0:return[i,s,r];case 1:return[l,i,r];case 2:return[r,i,s];case 3:return[r,l,i];case 4:return[s,r,i];case 5:return[i,r,l]}}function y(t){var e=t[0],n=t[1]/100,i=t[2]/100,a,o;return a=n*i,[e,100*(a=(a/=(o=(2-n)*i)<=1?o:2-o)||0),100*(o/=2)]}function k(t){return a(x(t))}function w(t){return o(x(t))}function M(t){return s(x(t))}// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
function C(t){var e=t[0]/360,n=t[1]/100,i=t[2]/100,a=n+i,o,l,s,u;// wh + bl cant be > 1
// linear interpolation
switch(1<a&&(n/=a,i/=a),s=6*e-(o=Math.floor(6*e)),0!=(1&o)&&(s=1-s),u=n+s*((l=1-i)-n),o){default:case 6:case 0:r=l,g=u,b=n;break;case 1:r=u,g=l,b=n;break;case 2:r=n,g=l,b=u;break;case 3:r=n,g=u,b=l;break;case 4:r=u,g=n,b=l;break;case 5:r=l,g=n,b=u;break}return[255*r,255*g,255*b]}function S(t){return l(C(t))}function _(t){return i(C(t))}function D(t){return o(C(t))}function P(t){return s(C(t))}function I(t){var e=t[0]/100,n=t[1]/100,i=t[2]/100,a=t[3]/100,o,r,l;return[255*(o=1-Math.min(1,e*(1-a)+a)),255*(r=1-Math.min(1,n*(1-a)+a)),255*(l=1-Math.min(1,i*(1-a)+a))]}function A(t){return l(I(t))}function T(t){return i(I(t))}function F(t){return a(I(t))}function O(t){return s(I(t))}function R(t){var e=t[0]/100,n=t[1]/100,i=t[2]/100,a,o,r;return o=-.9689*e+1.8758*n+.0415*i,r=.0557*e+-.204*n+1.057*i,// assume sRGB
a=.0031308<(a=3.2406*e+-1.5372*n+-.4986*i)?1.055*Math.pow(a,1/2.4)-.055:a*=12.92,o=.0031308<o?1.055*Math.pow(o,1/2.4)-.055:o*=12.92,r=.0031308<r?1.055*Math.pow(r,1/2.4)-.055:r*=12.92,[255*(a=Math.min(Math.max(0,a),1)),255*(o=Math.min(Math.max(0,o),1)),255*(r=Math.min(Math.max(0,r),1))]}function L(t){var e=t[0],n=t[1],i=t[2],a,o,r;return n/=100,i/=108.883,e=.008856<(e/=95.047)?Math.pow(e,1/3):7.787*e+16/116,[a=116*(n=.008856<n?Math.pow(n,1/3):7.787*n+16/116)-16,o=500*(e-n),r=200*(n-(i=.008856<i?Math.pow(i,1/3):7.787*i+16/116))]}function z(t){return B(L(t))}function N(t){var e=t[0],n=t[1],i=t[2],a,o,r,l;return l=e<=8?(o=100*e/903.3)/100*7.787+16/116:(o=100*Math.pow((e+16)/116,3),Math.pow(o/100,1/3)),[a=a/95.047<=.008856?a=95.047*(n/500+l-16/116)/7.787:95.047*Math.pow(n/500+l,3),o,r=r/108.883<=.008859?r=108.883*(l-i/200-16/116)/7.787:108.883*Math.pow(l-i/200,3)]}function B(t){var e=t[0],n=t[1],i=t[2],a,o,r;return(o=360*(a=Math.atan2(i,n))/2/Math.PI)<0&&(o+=360),[e,r=Math.sqrt(n*n+i*i),o]}function W(t){return R(N(t))}function V(t){var e=t[0],n=t[1],i,a,o,r;return r=t[2]/360*2*Math.PI,[e,a=n*Math.cos(r),o=n*Math.sin(r)]}function E(t){return N(V(t))}function H(t){return W(V(t))}function j(t){return J[t]}function q(t){return l(j(t))}function Y(t){return i(j(t))}function U(t){return a(j(t))}function X(t){return o(j(t))}function K(t){return d(j(t))}function G(t){return u(j(t))}
/* MIT license */
e.exports={rgb2hsl:l,rgb2hsv:i,rgb2hwb:a,rgb2cmyk:o,rgb2keyword:s,rgb2xyz:u,rgb2lab:d,rgb2lch:c,hsl2rgb:h,hsl2hsv:f,hsl2hwb:p,hsl2cmyk:m,hsl2keyword:v,hsv2rgb:x,hsv2hsl:y,hsv2hwb:k,hsv2cmyk:w,hsv2keyword:M,hwb2rgb:C,hwb2hsl:S,hwb2hsv:_,hwb2cmyk:D,hwb2keyword:P,cmyk2rgb:I,cmyk2hsl:A,cmyk2hsv:T,cmyk2hwb:F,cmyk2keyword:O,keyword2rgb:j,keyword2hsl:q,keyword2hsv:Y,keyword2hwb:U,keyword2cmyk:X,keyword2lab:K,keyword2xyz:G,xyz2rgb:R,xyz2lab:L,xyz2lch:z,lab2xyz:N,lab2rgb:W,lab2lch:B,lch2lab:V,lch2xyz:E,lch2rgb:H};var J={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},Z={};for(var Q in J)Z[JSON.stringify(J[Q])]=Q},{}],5:[function(t,e,n){var a=t(4),o=function t(){return new u};for(var i in a){
// export Raw versions
o[i+"Raw"]=function(e){
// accept array or plain args
return function(t){return"number"==typeof t&&(t=Array.prototype.slice.call(arguments)),a[e](t)}}(i);var r=/(\w+)2(\w+)/.exec(i),l=r[1],s=r[2];// export rgb2hsl and ["rgb"]["hsl"]
o[l]=o[l]||{},o[l][s]=o[i]=function(i){return function(t){"number"==typeof t&&(t=Array.prototype.slice.call(arguments));var e=a[i](t);if("string"==typeof e||void 0===e)return e;// keyword
for(var n=0;n<e.length;n++)e[n]=Math.round(e[n]);return e}}(i)}
/* Converter does lazy conversion and caching */var u=function t(){this.convs={}};
/* Either get the values for a space or
        set the values for a space, depending on args */u.prototype.routeSpace=function(t,e){var n=e[0];return void 0===n?this.getValues(t):(// color.rgb(10, 10, 10)
"number"==typeof n&&(n=Array.prototype.slice.call(e)),this.setValues(t,n))},
/* Set the values for a space, invalidating cache */
u.prototype.setValues=function(t,e){return this.space=t,this.convs={},this.convs[t]=e,this},
/* Get the values for a space. If there's already
        a conversion for the space, fetch it, otherwise
        compute it */
u.prototype.getValues=function(t){var e=this.convs[t];if(!e){var n=this.space,i=this.convs[n];e=o[n][t](i),this.convs[t]=e}return e},["rgb","hsl","hsv","cmyk","keyword"].forEach(function(e){u.prototype[e]=function(t){return this.routeSpace(e,arguments)}}),e.exports=o},{4:4}],6:[function(t,e,n){e.exports={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]}},{}],7:[function(t,e,n){
/**
       * @namespace Chart
       */
var i=t(30)();i.helpers=t(46),// @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!
t(28)(i),i.Animation=t(22),i.animationService=t(23),i.defaults=t(26),i.Element=t(27),i.elements=t(41),i.Interaction=t(29),i.layouts=t(31),i.platform=t(49),i.plugins=t(32),i.Scale=t(33),i.scaleService=t(34),i.Ticks=t(35),i.Tooltip=t(36),t(24)(i),t(25)(i),t(56)(i),t(54)(i),t(55)(i),t(57)(i),t(58)(i),t(59)(i),// Controllers must be loaded after elements
// See Chart.core.datasetController.dataElementType
t(15)(i),t(16)(i),t(17)(i),t(18)(i),t(19)(i),t(20)(i),t(21)(i),t(8)(i),t(9)(i),t(10)(i),t(11)(i),t(12)(i),t(13)(i),t(14)(i);// Loading built-in plugins
var a=t(50);for(var o in a)a.hasOwnProperty(o)&&i.plugins.register(a[o]);i.platform.initialize(),e.exports=i,"undefined"!=typeof window&&(window.Chart=i),// DEPRECATIONS
/**
       * Provided for backward compatibility, not available anymore
       * @namespace Chart.Legend
       * @deprecated since version 2.1.5
       * @todo remove at version 3
       * @private
       */
i.Legend=a.legend._element,
/**
       * Provided for backward compatibility, not available anymore
       * @namespace Chart.Title
       * @deprecated since version 2.1.5
       * @todo remove at version 3
       * @private
       */
i.Title=a.title._element,
/**
       * Provided for backward compatibility, use Chart.plugins instead
       * @namespace Chart.pluginService
       * @deprecated since version 2.1.5
       * @todo remove at version 3
       * @private
       */
i.pluginService=i.plugins,
/**
       * Provided for backward compatibility, inheriting from Chart.PlugingBase has no
       * effect, instead simply create/register plugins via plain JavaScript objects.
       * @interface Chart.PluginBase
       * @deprecated since version 2.5.0
       * @todo remove at version 3
       * @private
       */
i.PluginBase=i.Element.extend({}),
/**
       * Provided for backward compatibility, use Chart.helpers.canvas instead.
       * @namespace Chart.canvasHelpers
       * @deprecated since version 2.6.0
       * @todo remove at version 3
       * @private
       */
i.canvasHelpers=i.helpers.canvas,
/**
       * Provided for backward compatibility, use Chart.layouts instead.
       * @namespace Chart.layoutService
       * @deprecated since version 2.8.0
       * @todo remove at version 3
       * @private
       */
i.layoutService=i.layouts},{10:10,11:11,12:12,13:13,14:14,15:15,16:16,17:17,18:18,19:19,20:20,21:21,22:22,23:23,24:24,25:25,26:26,27:27,28:28,29:29,30:30,31:31,32:32,33:33,34:34,35:35,36:36,41:41,46:46,49:49,50:50,54:54,55:55,56:56,57:57,58:58,59:59,8:8,9:9}],8:[function(t,e,n){e.exports=function(n){n.Bar=function(t,e){return e.type="bar",new n(t,e)}}},{}],9:[function(t,e,n){e.exports=function(n){n.Bubble=function(t,e){return e.type="bubble",new n(t,e)}}},{}],10:[function(t,e,n){e.exports=function(n){n.Doughnut=function(t,e){return e.type="doughnut",new n(t,e)}}},{}],11:[function(t,e,n){e.exports=function(n){n.Line=function(t,e){return e.type="line",new n(t,e)}}},{}],12:[function(t,e,n){e.exports=function(n){n.PolarArea=function(t,e){return e.type="polarArea",new n(t,e)}}},{}],13:[function(t,e,n){e.exports=function(n){n.Radar=function(t,e){return e.type="radar",new n(t,e)}}},{}],14:[function(t,e,n){e.exports=function(n){n.Scatter=function(t,e){return e.type="scatter",new n(t,e)}}},{}],15:[function(t,e,n){
/**
       * Computes the "optimal" sample size to maintain bars equally sized while preventing overlap.
       * @private
       */
function h(t,e){var n=t.isHorizontal()?t.width:t.height,i=t.getTicks(),a,o,r,l;for(r=1,l=e.length;r<l;++r)n=Math.min(n,e[r]-e[r-1]);for(r=0,l=i.length;r<l;++r)o=t.getPixelForTick(r),n=0<r?Math.min(n,o-a):n,a=o;return n}
/**
       * Computes an "ideal" category based on the absolute bar thickness or, if undefined or null,
       * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This
       * mode currently always generates bars equally sized (until we introduce scriptable options?).
       * @private
       */function d(t,e,n){var i=n.barThickness,a=e.stackCount,o=e.pixels[t],r,l;return l=f.isNullOrUndef(i)?(r=e.min*n.categoryPercentage,n.barPercentage):(
// When bar thickness is enforced, category and bar percentages are ignored.
// Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')
// and deprecate barPercentage since this value is ignored when thickness is absolute.
r=i*a,1),{chunk:r/a,ratio:l,start:o-r/2}}
/**
       * Computes an "optimal" category that globally arranges bars side by side (no gap when
       * percentage options are 1), based on the previous and following categories. This mode
       * generates bars with different widths when data are not evenly spaced.
       * @private
       */function c(t,e,n){var i=e.pixels,a=i[t],o=0<t?i[t-1]:null,r=t<i.length-1?i[t+1]:null,l=n.categoryPercentage,s,u;return null===o&&(
// first data: its size is double based on the next point or,
// if it's also the last data, we use the scale end extremity.
o=a-(null===r?e.end-a:r-a)),null===r&&(
// last data: its size is also double based on the previous point.
r=a+a-o),s=a-(a-o)/2*l,{chunk:(u=(r-o)/2*l)/e.stackCount,ratio:n.barPercentage,start:s}}var i=t(26),a=t(41),f=t(46);i._set("bar",{hover:{mode:"label"},scales:{xAxes:[{type:"category",
// Specific to Bar Controller
categoryPercentage:.8,barPercentage:.9,
// offset settings
offset:!0,
// grid line settings
gridLines:{offsetGridLines:!0}}],yAxes:[{type:"linear"}]}}),i._set("horizontalBar",{hover:{mode:"index",axis:"y"},scales:{xAxes:[{type:"linear",position:"bottom"}],yAxes:[{position:"left",type:"category",
// Specific to Horizontal Bar Controller
categoryPercentage:.8,barPercentage:.9,
// offset settings
offset:!0,
// grid line settings
gridLines:{offsetGridLines:!0}}]},elements:{rectangle:{borderSkipped:"left"}},tooltips:{callbacks:{title:function t(e,n){
// Pick first xLabel for now
var t="";return 0<e.length&&(e[0].yLabel?t=e[0].yLabel:0<n.labels.length&&e[0].index<n.labels.length&&(t=n.labels[e[0].index])),t},label:function t(e,n){var i;return(n.datasets[e.datasetIndex].label||"")+": "+e.xLabel}},mode:"index",axis:"y"}}),e.exports=function(i){i.controllers.bar=i.DatasetController.extend({dataElementType:a.Rectangle,initialize:function t(){var e=this,n;i.DatasetController.prototype.initialize.apply(e,arguments),(n=e.getMeta()).stack=e.getDataset().stack,n.bar=!0},update:function t(e){var n=this,i=n.getMeta().data,a,o;for(n._ruler=n.getRuler(),a=0,o=i.length;a<o;++a)n.updateElement(i[a],a,e)},updateElement:function t(e,n,i){var a=this,o=a.chart,r=a.getMeta(),l=a.getDataset(),s=e.custom||{},u=o.options.elements.rectangle;e._xScale=a.getScaleForId(r.xAxisID),e._yScale=a.getScaleForId(r.yAxisID),e._datasetIndex=a.index,e._index=n,e._model={datasetLabel:l.label,label:o.data.labels[n],borderSkipped:s.borderSkipped?s.borderSkipped:u.borderSkipped,backgroundColor:s.backgroundColor?s.backgroundColor:f.valueAtIndexOrDefault(l.backgroundColor,n,u.backgroundColor),borderColor:s.borderColor?s.borderColor:f.valueAtIndexOrDefault(l.borderColor,n,u.borderColor),borderWidth:s.borderWidth?s.borderWidth:f.valueAtIndexOrDefault(l.borderWidth,n,u.borderWidth)},a.updateElementGeometry(e,n,i),e.pivot()},
/**
           * @private
           */
updateElementGeometry:function t(e,n,i){var a=this,o=e._model,r=a.getValueScale(),l=r.getBasePixel(),s=r.isHorizontal(),u=a._ruler||a.getRuler(),d=a.calculateBarValuePixels(a.index,n),c=a.calculateBarIndexPixels(a.index,n,u);o.horizontal=s,o.base=i?l:d.base,o.x=s?i?l:d.head:c.center,o.y=s?c.center:i?l:d.head,o.height=s?c.size:void 0,o.width=s?void 0:c.size},
/**
           * @private
           */
getValueScaleId:function t(){return this.getMeta().yAxisID},
/**
           * @private
           */
getIndexScaleId:function t(){return this.getMeta().xAxisID},
/**
           * @private
           */
getValueScale:function t(){return this.getScaleForId(this.getValueScaleId())},
/**
           * @private
           */
getIndexScale:function t(){return this.getScaleForId(this.getIndexScaleId())},
/**
           * Returns the stacks based on groups and bar visibility.
           * @param {Number} [last] - The dataset index
           * @returns {Array} The stack list
           * @private
           */
_getStacks:function t(e){var n=this,i=n.chart,a,o=n.getIndexScale().options.stacked,r=void 0===e?i.data.datasets.length:e+1,l=[],s,u;for(s=0;s<r;++s)(u=i.getDatasetMeta(s)).bar&&i.isDatasetVisible(s)&&(!1===o||!0===o&&-1===l.indexOf(u.stack)||void 0===o&&(void 0===u.stack||-1===l.indexOf(u.stack)))&&l.push(u.stack);return l},
/**
           * Returns the effective number of stacks based on groups and bar visibility.
           * @private
           */
getStackCount:function t(){return this._getStacks().length},
/**
           * Returns the stack index for the given dataset based on groups and bar visibility.
           * @param {Number} [datasetIndex] - The dataset index
           * @param {String} [name] - The stack name to find
           * @returns {Number} The stack index
           * @private
           */
getStackIndex:function t(e,n){var i=this._getStacks(e),a=void 0!==n?i.indexOf(n):-1;// indexOf returns -1 if element is not present
return-1===a?i.length-1:a},
/**
           * @private
           */
getRuler:function t(){var e=this,n=e.getIndexScale(),i=e.getStackCount(),a=e.index,o=n.isHorizontal(),r=o?n.left:n.top,l=r+(o?n.width:n.height),s=[],u,d,c;for(u=0,d=e.getMeta().data.length;u<d;++u)s.push(n.getPixelForValue(null,u,a));return{min:c=f.isNullOrUndef(n.options.barThickness)?h(n,s):-1,pixels:s,start:r,end:l,stackCount:i,scale:n}},
/**
           * Note: pixel values are not clamped to the scale area.
           * @private
           */
calculateBarValuePixels:function t(e,n){var i=this,a=i.chart,o=i.getMeta(),r=i.getValueScale(),l=a.data.datasets,s=r.getRightValue(l[e].data[n]),u=r.options.stacked,d=o.stack,c=0,h,f,g,p,m,v;if(u||void 0===u&&void 0!==d)for(h=0;h<e;++h)(f=a.getDatasetMeta(h)).bar&&f.stack===d&&f.controller.getValueScaleId()===r.id&&a.isDatasetVisible(h)&&(g=r.getRightValue(l[h].data[n]),(s<0&&g<0||0<=s&&0<g)&&(c+=g));return p=r.getPixelForValue(c),{size:v=((m=r.getPixelForValue(c+s))-p)/2,base:p,head:m,center:m+v/2}},
/**
           * @private
           */
calculateBarIndexPixels:function t(e,n,i){var a=this,o=i.scale.options,r="flex"===o.barThickness?c(n,i,o):d(n,i,o),l=a.getStackIndex(e,a.getMeta().stack),s=r.start+r.chunk*l+r.chunk/2,u=Math.min(f.valueOrDefault(o.maxBarThickness,1/0),r.chunk*r.ratio);return{base:s-u/2,head:s+u/2,center:s,size:u}},draw:function t(){var e=this,n=e.chart,i=e.getValueScale(),a=e.getMeta().data,o=e.getDataset(),r=a.length,l=0;for(f.canvas.clipArea(n.ctx,n.chartArea);l<r;++l)isNaN(i.getRightValue(o.data[l]))||a[l].draw();f.canvas.unclipArea(n.ctx)}}),i.controllers.horizontalBar=i.controllers.bar.extend({
/**
           * @private
           */
getValueScaleId:function t(){return this.getMeta().xAxisID},
/**
           * @private
           */
getIndexScaleId:function t(){return this.getMeta().yAxisID}})}},{26:26,41:41,46:46}],16:[function(t,e,n){var i=t(26),a=t(41),v=t(46);i._set("bubble",{hover:{mode:"single"},scales:{xAxes:[{type:"linear",
// bubble should probably use a linear scale by default
position:"bottom",id:"x-axis-0"}],yAxes:[{type:"linear",position:"left",id:"y-axis-0"}]},tooltips:{callbacks:{title:function t(){
// Title doesn't make sense for scatter since we format the data as a point
return""},label:function t(e,n){var i=n.datasets[e.datasetIndex].label||"",a=n.datasets[e.datasetIndex].data[e.index];return i+": ("+e.xLabel+", "+e.yLabel+", "+a.r+")"}}}}),e.exports=function(t){t.controllers.bubble=t.DatasetController.extend({
/**
           * @protected
           */
dataElementType:a.Point,
/**
           * @protected
           */
update:function t(n){var i=this,e,a=i.getMeta().data;// Update Points
v.each(a,function(t,e){i.updateElement(t,e,n)})},
/**
           * @protected
           */
updateElement:function t(e,n,i){var a=this,o=a.getMeta(),r=e.custom||{},l=a.getScaleForId(o.xAxisID),s=a.getScaleForId(o.yAxisID),u=a._resolveElementOptions(e,n),d=a.getDataset().data[n],c=a.index,h=i?l.getPixelForDecimal(.5):l.getPixelForValue("object"===_typeof(d)?d:NaN,n,c),f=i?s.getBasePixel():s.getPixelForValue(d,n,c);e._xScale=l,e._yScale=s,e._options=u,e._datasetIndex=c,e._index=n,e._model={backgroundColor:u.backgroundColor,borderColor:u.borderColor,borderWidth:u.borderWidth,hitRadius:u.hitRadius,pointStyle:u.pointStyle,rotation:u.rotation,radius:i?0:u.radius,skip:r.skip||isNaN(h)||isNaN(f),x:h,y:f},e.pivot()},
/**
           * @protected
           */
setHoverStyle:function t(e){var n=e._model,i=e._options;e.$previousStyle={backgroundColor:n.backgroundColor,borderColor:n.borderColor,borderWidth:n.borderWidth,radius:n.radius},n.backgroundColor=v.valueOrDefault(i.hoverBackgroundColor,v.getHoverColor(i.backgroundColor)),n.borderColor=v.valueOrDefault(i.hoverBorderColor,v.getHoverColor(i.borderColor)),n.borderWidth=v.valueOrDefault(i.hoverBorderWidth,i.borderWidth),n.radius=i.radius+i.hoverRadius},
/**
           * @private
           */
_resolveElementOptions:function t(e,n){var i=this,a=i.chart,o,r=a.data.datasets[i.index],l=e.custom||{},s=a.options.elements.point,u=v.options.resolve,d=r.data[n],c={},h,f,g,p={chart:a,dataIndex:n,dataset:r,datasetIndex:i.index},m=["backgroundColor","borderColor","borderWidth","hoverBackgroundColor","hoverBorderColor","hoverBorderWidth","hoverRadius","hitRadius","pointStyle","rotation"];for(h=0,f=m.length;h<f;++h)c[g=m[h]]=u([l[g],r[g],s[g]],p,n);// Custom radius resolution
return c.radius=u([l.radius,d?d.r:void 0,r.radius,s.radius],p,n),c}})}},{26:26,41:41,46:46}],17:[function(t,e,n){var i=t(26),a=t(41),T=t(46);i._set("doughnut",{animation:{
// Boolean - Whether we animate the rotation of the Doughnut
animateRotate:!0,
// Boolean - Whether we animate scaling the Doughnut from the centre
animateScale:!1},hover:{mode:"single"},legendCallback:function t(e){var n=[];n.push('<ul class="'+e.id+'-legend">');var i=e.data,a=i.datasets,o=i.labels;if(a.length)for(var r=0;r<a[0].data.length;++r)n.push('<li><span style="background-color:'+a[0].backgroundColor[r]+'"></span>'),o[r]&&n.push(o[r]),n.push("</li>");return n.push("</ul>"),n.join("")},legend:{labels:{generateLabels:function t(c){var h=c.data;return h.labels.length&&h.datasets.length?h.labels.map(function(t,e){var n=c.getDatasetMeta(0),i=h.datasets[0],a=n.data[e],o=a&&a.custom||{},r=T.valueAtIndexOrDefault,l=c.options.elements.arc,s,u,d;return{text:t,fillStyle:o.backgroundColor?o.backgroundColor:r(i.backgroundColor,e,l.backgroundColor),strokeStyle:o.borderColor?o.borderColor:r(i.borderColor,e,l.borderColor),lineWidth:o.borderWidth?o.borderWidth:r(i.borderWidth,e,l.borderWidth),hidden:isNaN(i.data[e])||n.data[e].hidden,
// Extra data used for toggling the correct item
index:e}}):[]}},onClick:function t(e,n){var i=n.index,a=this.chart,o,r,l;for(o=0,r=(a.data.datasets||[]).length;o<r;++o)// toggle visibility of index if exists
(l=a.getDatasetMeta(o)).data[i]&&(l.data[i].hidden=!l.data[i].hidden);a.update()}},
// The percentage of the chart that we cut out of the middle.
cutoutPercentage:50,
// The rotation of the chart, where the first data arc begins.
rotation:-.5*Math.PI,
// The total circumference of the chart.
circumference:2*Math.PI,
// Need to override these to give a nice default
tooltips:{callbacks:{title:function t(){return""},label:function t(e,n){var i=n.labels[e.index],a=": "+n.datasets[e.datasetIndex].data[e.index];return T.isArray(i)?(
// show value on first line of multiline label
// need to clone because we are changing the value
i=i.slice())[0]+=a:i+=a,i}}}}),i._set("pie",T.clone(i.doughnut)),i._set("pie",{cutoutPercentage:0}),e.exports=function(t){t.controllers.doughnut=t.controllers.pie=t.DatasetController.extend({dataElementType:a.Arc,linkScales:T.noop,
// Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly
getRingIndex:function t(e){for(var n=0,i=0;i<e;++i)this.chart.isDatasetVisible(i)&&++n;return n},update:function t(n){var i=this,e=i.chart,a=e.chartArea,o=e.options,r=o.elements.arc,l=a.right-a.left-r.borderWidth,s=a.bottom-a.top-r.borderWidth,u=Math.min(l,s),d={x:0,y:0},c=i.getMeta(),h=o.cutoutPercentage,f=o.circumference;// If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc
if(f<2*Math.PI){var g=o.rotation%(2*Math.PI),p=(g+=2*Math.PI*(g>=Math.PI?-1:g<-Math.PI?1:0))+f,m=Math.cos(g),v=Math.sin(g),b=Math.cos(p),x=Math.sin(p),y=g<=0&&0<=p||g<=2*Math.PI&&2*Math.PI<=p,k=g<=.5*Math.PI&&.5*Math.PI<=p||g<=2.5*Math.PI&&2.5*Math.PI<=p,w=g<=-Math.PI&&-Math.PI<=p||g<=Math.PI&&Math.PI<=p,M=g<=.5*-Math.PI&&.5*-Math.PI<=p||g<=1.5*Math.PI&&1.5*Math.PI<=p,C=h/100,S=w?-1:Math.min(m*(m<0?1:C),b*(b<0?1:C)),_=M?-1:Math.min(v*(v<0?1:C),x*(x<0?1:C)),D=y?1:Math.max(m*(0<m?1:C),b*(0<b?1:C)),P=k?1:Math.max(v*(0<v?1:C),x*(0<x?1:C)),I=.5*(D-S),A=.5*(P-_);u=Math.min(l/I,s/A),d={x:-.5*(D+S),y:-.5*(P+_)}}e.borderWidth=i.getMaxBorderWidth(c.data),e.outerRadius=Math.max((u-e.borderWidth)/2,0),e.innerRadius=Math.max(h?e.outerRadius/100*h:0,0),e.radiusLength=(e.outerRadius-e.innerRadius)/e.getVisibleDatasetCount(),e.offsetX=d.x*e.outerRadius,e.offsetY=d.y*e.outerRadius,c.total=i.calculateTotal(),i.outerRadius=e.outerRadius-e.radiusLength*i.getRingIndex(i.index),i.innerRadius=Math.max(i.outerRadius-e.radiusLength,0),T.each(c.data,function(t,e){i.updateElement(t,e,n)})},updateElement:function t(e,n,i){var a=this,o=a.chart,r=o.chartArea,l=o.options,s=l.animation,u=(r.left+r.right)/2,d=(r.top+r.bottom)/2,c=l.rotation,h=l.rotation,f=a.getDataset(),g=i&&s.animateRotate?0:e.hidden?0:a.calculateCircumference(f.data[n])*(l.circumference/(2*Math.PI)),p=i&&s.animateScale?0:a.innerRadius,m=i&&s.animateScale?0:a.outerRadius,v=T.valueAtIndexOrDefault;T.extend(e,{
// Utility
_datasetIndex:a.index,_index:n,
// Desired view properties
_model:{x:u+o.offsetX,y:d+o.offsetY,startAngle:c,endAngle:h,circumference:g,outerRadius:m,innerRadius:p,label:v(f.label,n,o.data.labels[n])}});var b=e._model,x=e.custom||{},y=T.valueAtIndexOrDefault,k=this.chart.options.elements.arc;// Resets the visual styles
b.backgroundColor=x.backgroundColor?x.backgroundColor:y(f.backgroundColor,n,k.backgroundColor),b.borderColor=x.borderColor?x.borderColor:y(f.borderColor,n,k.borderColor),b.borderWidth=x.borderWidth?x.borderWidth:y(f.borderWidth,n,k.borderWidth),// Set correct angles if not resetting
i&&s.animateRotate||(b.startAngle=0===n?l.rotation:a.getMeta().data[n-1]._model.endAngle,b.endAngle=b.startAngle+b.circumference),e.pivot()},calculateTotal:function t(){var n=this.getDataset(),e=this.getMeta(),i=0,a;
/* if (total === 0) {
            	total = NaN;
            }*/
return T.each(e.data,function(t,e){a=n.data[e],isNaN(a)||t.hidden||(i+=Math.abs(a))}),i},calculateCircumference:function t(e){var n=this.getMeta().total;return 0<n&&!isNaN(e)?2*Math.PI*(Math.abs(e)/n):0},
// gets the max border or hover width to properly scale pie charts
getMaxBorderWidth:function t(e){for(var n=0,i=this.index,a=e.length,o,r,l=0;l<a;l++)n=(n=n<(o=e[l]._model?e[l]._model.borderWidth:0)?o:n)<(r=e[l]._chart?e[l]._chart.config.data.datasets[i].hoverBorderWidth:0)?r:n;return n}})}},{26:26,41:41,46:46}],18:[function(t,e,n){var i=t(26),a=t(41),p=t(46);i._set("line",{showLines:!0,spanGaps:!1,hover:{mode:"label"},scales:{xAxes:[{type:"category",id:"x-axis-0"}],yAxes:[{type:"linear",id:"y-axis-0"}]}}),e.exports=function(t){function g(t,e){return p.valueOrDefault(t.showLine,e.showLines)}t.controllers.line=t.DatasetController.extend({datasetElementType:a.Line,dataElementType:a.Point,update:function t(e){var n=this,i=n.getMeta(),a=i.dataset,o=i.data||[],r=n.chart.options,l=r.elements.line,s=n.getScaleForId(i.yAxisID),u,d,c,h=n.getDataset(),f=g(h,r);// Update Points
for(// Update Line
f&&(c=a.custom||{},// Compatibility: If the properties are defined with only the old name, use those values
void 0!==h.tension&&void 0===h.lineTension&&(h.lineTension=h.tension),// Utility
a._scale=s,a._datasetIndex=n.index,// Data
a._children=o,// Model
a._model={
// Appearance
// The default behavior of lines is to break at null values, according
// to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158
// This option gives lines the ability to span gaps
spanGaps:h.spanGaps?h.spanGaps:r.spanGaps,tension:c.tension?c.tension:p.valueOrDefault(h.lineTension,l.tension),backgroundColor:c.backgroundColor?c.backgroundColor:h.backgroundColor||l.backgroundColor,borderWidth:c.borderWidth?c.borderWidth:h.borderWidth||l.borderWidth,borderColor:c.borderColor?c.borderColor:h.borderColor||l.borderColor,borderCapStyle:c.borderCapStyle?c.borderCapStyle:h.borderCapStyle||l.borderCapStyle,borderDash:c.borderDash?c.borderDash:h.borderDash||l.borderDash,borderDashOffset:c.borderDashOffset?c.borderDashOffset:h.borderDashOffset||l.borderDashOffset,borderJoinStyle:c.borderJoinStyle?c.borderJoinStyle:h.borderJoinStyle||l.borderJoinStyle,fill:c.fill?c.fill:void 0!==h.fill?h.fill:l.fill,steppedLine:c.steppedLine?c.steppedLine:p.valueOrDefault(h.steppedLine,l.stepped),cubicInterpolationMode:c.cubicInterpolationMode?c.cubicInterpolationMode:p.valueOrDefault(h.cubicInterpolationMode,l.cubicInterpolationMode)},a.pivot()),u=0,d=o.length;u<d;++u)n.updateElement(o[u],u,e);// Now pivot the point for animation
for(f&&0!==a._model.tension&&n.updateBezierControlPoints(),u=0,d=o.length;u<d;++u)o[u].pivot()},getPointBackgroundColor:function t(e,n){var i=this.chart.options.elements.point.backgroundColor,a=this.getDataset(),o=e.custom||{};return o.backgroundColor?i=o.backgroundColor:a.pointBackgroundColor?i=p.valueAtIndexOrDefault(a.pointBackgroundColor,n,i):a.backgroundColor&&(i=a.backgroundColor),i},getPointBorderColor:function t(e,n){var i=this.chart.options.elements.point.borderColor,a=this.getDataset(),o=e.custom||{};return o.borderColor?i=o.borderColor:a.pointBorderColor?i=p.valueAtIndexOrDefault(a.pointBorderColor,n,i):a.borderColor&&(i=a.borderColor),i},getPointBorderWidth:function t(e,n){var i=this.chart.options.elements.point.borderWidth,a=this.getDataset(),o=e.custom||{};return isNaN(o.borderWidth)?!isNaN(a.pointBorderWidth)||p.isArray(a.pointBorderWidth)?i=p.valueAtIndexOrDefault(a.pointBorderWidth,n,i):isNaN(a.borderWidth)||(i=a.borderWidth):i=o.borderWidth,i},getPointRotation:function t(e,n){var i=this.chart.options.elements.point.rotation,a=this.getDataset(),o=e.custom||{};return isNaN(o.rotation)?isNaN(a.pointRotation)&&!p.isArray(a.pointRotation)||(i=p.valueAtIndexOrDefault(a.pointRotation,n,i)):i=o.rotation,i},updateElement:function t(e,n,i){var a=this,o=a.getMeta(),r=e.custom||{},l=a.getDataset(),s=a.index,u=l.data[n],d=a.getScaleForId(o.yAxisID),c=a.getScaleForId(o.xAxisID),h=a.chart.options.elements.point,f,g;// Compatibility: If the properties are defined with only the old name, use those values
void 0!==l.radius&&void 0===l.pointRadius&&(l.pointRadius=l.radius),void 0!==l.hitRadius&&void 0===l.pointHitRadius&&(l.pointHitRadius=l.hitRadius),f=c.getPixelForValue("object"===_typeof(u)?u:NaN,n,s),g=i?d.getBasePixel():a.calculatePointY(u,n,s),// Utility
e._xScale=c,e._yScale=d,e._datasetIndex=s,e._index=n,// Desired view properties
e._model={x:f,y:g,skip:r.skip||isNaN(f)||isNaN(g),
// Appearance
radius:r.radius||p.valueAtIndexOrDefault(l.pointRadius,n,h.radius),pointStyle:r.pointStyle||p.valueAtIndexOrDefault(l.pointStyle,n,h.pointStyle),rotation:a.getPointRotation(e,n),backgroundColor:a.getPointBackgroundColor(e,n),borderColor:a.getPointBorderColor(e,n),borderWidth:a.getPointBorderWidth(e,n),tension:o.dataset._model?o.dataset._model.tension:0,steppedLine:!!o.dataset._model&&o.dataset._model.steppedLine,
// Tooltip
hitRadius:r.hitRadius||p.valueAtIndexOrDefault(l.pointHitRadius,n,h.hitRadius)}},calculatePointY:function t(e,n,i){var a=this,o=a.chart,r=a.getMeta(),l=a.getScaleForId(r.yAxisID),s=0,u=0,d,c,h;if(l.options.stacked){for(d=0;d<i;d++)if(c=o.data.datasets[d],"line"===(h=o.getDatasetMeta(d)).type&&h.yAxisID===l.id&&o.isDatasetVisible(d)){var f=Number(l.getRightValue(c.data[n]));f<0?u+=f||0:s+=f||0}var g=Number(l.getRightValue(e));return g<0?l.getPixelForValue(u+g):l.getPixelForValue(s+g)}return l.getPixelForValue(e)},updateBezierControlPoints:function t(){function e(t,e,n){return Math.max(Math.min(t,n),e)}var n=this,i=n.getMeta(),a=n.chart.chartArea,o=i.data||[],r,l,s,u,d;if(// Only consider points that are drawn in case the spanGaps option is used
i.dataset._model.spanGaps&&(o=o.filter(function(t){return!t._model.skip})),"monotone"===i.dataset._model.cubicInterpolationMode)p.splineCurveMonotone(o);else for(r=0,l=o.length;r<l;++r)u=(s=o[r])._model,d=p.splineCurve(p.previousItem(o,r)._model,u,p.nextItem(o,r)._model,i.dataset._model.tension),u.controlPointPreviousX=d.previous.x,u.controlPointPreviousY=d.previous.y,u.controlPointNextX=d.next.x,u.controlPointNextY=d.next.y;if(n.chart.options.elements.line.capBezierPoints)for(r=0,l=o.length;r<l;++r)(u=o[r]._model).controlPointPreviousX=e(u.controlPointPreviousX,a.left,a.right),u.controlPointPreviousY=e(u.controlPointPreviousY,a.top,a.bottom),u.controlPointNextX=e(u.controlPointNextX,a.left,a.right),u.controlPointNextY=e(u.controlPointNextY,a.top,a.bottom)},draw:function t(){var e=this,n=e.chart,i=e.getMeta(),a=i.data||[],o=n.chartArea,r=a.length,l,s=0;// Draw the points
for(g(e.getDataset(),n.options)&&(l=(i.dataset._model.borderWidth||0)/2,p.canvas.clipArea(n.ctx,{left:o.left,right:o.right,top:o.top-l,bottom:o.bottom+l}),i.dataset.draw(),p.canvas.unclipArea(n.ctx));s<r;++s)a[s].draw(o)},setHoverStyle:function t(e){
// Point
var n=this.chart.data.datasets[e._datasetIndex],i=e._index,a=e.custom||{},o=e._model;e.$previousStyle={backgroundColor:o.backgroundColor,borderColor:o.borderColor,borderWidth:o.borderWidth,radius:o.radius},o.backgroundColor=a.hoverBackgroundColor||p.valueAtIndexOrDefault(n.pointHoverBackgroundColor,i,p.getHoverColor(o.backgroundColor)),o.borderColor=a.hoverBorderColor||p.valueAtIndexOrDefault(n.pointHoverBorderColor,i,p.getHoverColor(o.borderColor)),o.borderWidth=a.hoverBorderWidth||p.valueAtIndexOrDefault(n.pointHoverBorderWidth,i,o.borderWidth),o.radius=a.hoverRadius||p.valueAtIndexOrDefault(n.pointHoverRadius,i,this.chart.options.elements.point.hoverRadius)}})}},{26:26,41:41,46:46}],19:[function(t,e,n){var i=t(26),a=t(41),w=t(46);i._set("polarArea",{scale:{type:"radialLinear",angleLines:{display:!1},gridLines:{circular:!0},pointLabels:{display:!1},ticks:{beginAtZero:!0}},
// Boolean - Whether to animate the rotation of the chart
animation:{animateRotate:!0,animateScale:!0},startAngle:-.5*Math.PI,legendCallback:function t(e){var n=[];n.push('<ul class="'+e.id+'-legend">');var i=e.data,a=i.datasets,o=i.labels;if(a.length)for(var r=0;r<a[0].data.length;++r)n.push('<li><span style="background-color:'+a[0].backgroundColor[r]+'"></span>'),o[r]&&n.push(o[r]),n.push("</li>");return n.push("</ul>"),n.join("")},legend:{labels:{generateLabels:function t(c){var h=c.data;return h.labels.length&&h.datasets.length?h.labels.map(function(t,e){var n=c.getDatasetMeta(0),i=h.datasets[0],a,o=n.data[e].custom||{},r=w.valueAtIndexOrDefault,l=c.options.elements.arc,s,u,d;return{text:t,fillStyle:o.backgroundColor?o.backgroundColor:r(i.backgroundColor,e,l.backgroundColor),strokeStyle:o.borderColor?o.borderColor:r(i.borderColor,e,l.borderColor),lineWidth:o.borderWidth?o.borderWidth:r(i.borderWidth,e,l.borderWidth),hidden:isNaN(i.data[e])||n.data[e].hidden,
// Extra data used for toggling the correct item
index:e}}):[]}},onClick:function t(e,n){var i=n.index,a=this.chart,o,r,l;for(o=0,r=(a.data.datasets||[]).length;o<r;++o)(l=a.getDatasetMeta(o)).data[i].hidden=!l.data[i].hidden;a.update()}},
// Need to override these to give a nice default
tooltips:{callbacks:{title:function t(){return""},label:function t(e,n){return n.labels[e.index]+": "+e.yLabel}}}}),e.exports=function(t){t.controllers.polarArea=t.DatasetController.extend({dataElementType:a.Arc,linkScales:w.noop,update:function t(n){var i=this,e=i.getDataset(),a=i.getMeta(),o=i.chart.options.startAngle||0,r=i._starts=[],l=i._angles=[],s,u,d;for(i._updateRadius(),a.count=i.countVisibleElements(),s=0,u=e.data.length;s<u;s++)r[s]=o,d=i._computeAngle(s),o+=l[s]=d;w.each(a.data,function(t,e){i.updateElement(t,e,n)})},
/**
           * @private
           */
_updateRadius:function t(){var e=this,n=e.chart,i=n.chartArea,a=n.options,o=a.elements.arc,r=Math.min(i.right-i.left,i.bottom-i.top);n.outerRadius=Math.max((r-o.borderWidth/2)/2,0),n.innerRadius=Math.max(a.cutoutPercentage?n.outerRadius/100*a.cutoutPercentage:1,0),n.radiusLength=(n.outerRadius-n.innerRadius)/n.getVisibleDatasetCount(),e.outerRadius=n.outerRadius-n.radiusLength*e.index,e.innerRadius=e.outerRadius-n.radiusLength},updateElement:function t(e,n,i){var a=this,o=a.chart,r=a.getDataset(),l=o.options,s=l.animation,u=o.scale,d=o.data.labels,c=u.xCenter,h=u.yCenter,f=l.startAngle,g=e.hidden?0:u.getDistanceFromCenterForValue(r.data[n]),p=a._starts[n],m=p+(e.hidden?0:a._angles[n]),v=s.animateScale?0:u.getDistanceFromCenterForValue(r.data[n]);w.extend(e,{
// Utility
_datasetIndex:a.index,_index:n,_scale:u,
// Desired view properties
_model:{x:c,y:h,innerRadius:0,outerRadius:i?v:g,startAngle:i&&s.animateRotate?f:p,endAngle:i&&s.animateRotate?f:m,label:w.valueAtIndexOrDefault(d,n,d[n])}});// Apply border and fill style
var b=this.chart.options.elements.arc,x=e.custom||{},y=w.valueAtIndexOrDefault,k=e._model;k.backgroundColor=x.backgroundColor?x.backgroundColor:y(r.backgroundColor,n,b.backgroundColor),k.borderColor=x.borderColor?x.borderColor:y(r.borderColor,n,b.borderColor),k.borderWidth=x.borderWidth?x.borderWidth:y(r.borderWidth,n,b.borderWidth),e.pivot()},countVisibleElements:function t(){var n=this.getDataset(),e=this.getMeta(),i=0;return w.each(e.data,function(t,e){isNaN(n.data[e])||t.hidden||i++}),i},
/**
           * @private
           */
_computeAngle:function t(e){var n=this,i=this.getMeta().count,a=n.getDataset(),o=n.getMeta();if(isNaN(a.data[e])||o.data[e].hidden)return 0;// Scriptable options
var r={chart:n.chart,dataIndex:e,dataset:a,datasetIndex:n.index};return w.options.resolve([n.chart.options.elements.arc.angle,2*Math.PI/i],r,e)}})}},{26:26,41:41,46:46}],20:[function(t,e,n){var i=t(26),a=t(41),d=t(46);i._set("radar",{scale:{type:"radialLinear"},elements:{line:{tension:0}}}),e.exports=function(t){t.controllers.radar=t.DatasetController.extend({datasetElementType:a.Line,dataElementType:a.Point,linkScales:d.noop,update:function t(n){var i=this,e=i.getMeta(),a=e.dataset,o=e.data,r=a.custom||{},l=i.getDataset(),s=i.chart.options.elements.line,u=i.chart.scale;// Compatibility: If the properties are defined with only the old name, use those values
void 0!==l.tension&&void 0===l.lineTension&&(l.lineTension=l.tension),d.extend(e.dataset,{
// Utility
_datasetIndex:i.index,_scale:u,
// Data
_children:o,_loop:!0,
// Model
_model:{
// Appearance
tension:r.tension?r.tension:d.valueOrDefault(l.lineTension,s.tension),backgroundColor:r.backgroundColor?r.backgroundColor:l.backgroundColor||s.backgroundColor,borderWidth:r.borderWidth?r.borderWidth:l.borderWidth||s.borderWidth,borderColor:r.borderColor?r.borderColor:l.borderColor||s.borderColor,fill:r.fill?r.fill:void 0!==l.fill?l.fill:s.fill,borderCapStyle:r.borderCapStyle?r.borderCapStyle:l.borderCapStyle||s.borderCapStyle,borderDash:r.borderDash?r.borderDash:l.borderDash||s.borderDash,borderDashOffset:r.borderDashOffset?r.borderDashOffset:l.borderDashOffset||s.borderDashOffset,borderJoinStyle:r.borderJoinStyle?r.borderJoinStyle:l.borderJoinStyle||s.borderJoinStyle}}),e.dataset.pivot(),// Update Points
d.each(o,function(t,e){i.updateElement(t,e,n)},i),// Update bezier control points
i.updateBezierControlPoints()},updateElement:function t(e,n,i){var a=this,o=e.custom||{},r=a.getDataset(),l=a.chart.scale,s=a.chart.options.elements.point,u=l.getPointPositionForValue(n,r.data[n]);// Compatibility: If the properties are defined with only the old name, use those values
void 0!==r.radius&&void 0===r.pointRadius&&(r.pointRadius=r.radius),void 0!==r.hitRadius&&void 0===r.pointHitRadius&&(r.pointHitRadius=r.hitRadius),d.extend(e,{
// Utility
_datasetIndex:a.index,_index:n,_scale:l,
// Desired view properties
_model:{x:i?l.xCenter:u.x,
// value not used in dataset scale, but we want a consistent API between scales
y:i?l.yCenter:u.y,
// Appearance
tension:o.tension?o.tension:d.valueOrDefault(r.lineTension,a.chart.options.elements.line.tension),radius:o.radius?o.radius:d.valueAtIndexOrDefault(r.pointRadius,n,s.radius),backgroundColor:o.backgroundColor?o.backgroundColor:d.valueAtIndexOrDefault(r.pointBackgroundColor,n,s.backgroundColor),borderColor:o.borderColor?o.borderColor:d.valueAtIndexOrDefault(r.pointBorderColor,n,s.borderColor),borderWidth:o.borderWidth?o.borderWidth:d.valueAtIndexOrDefault(r.pointBorderWidth,n,s.borderWidth),pointStyle:o.pointStyle?o.pointStyle:d.valueAtIndexOrDefault(r.pointStyle,n,s.pointStyle),rotation:o.rotation?o.rotation:d.valueAtIndexOrDefault(r.pointRotation,n,s.rotation),
// Tooltip
hitRadius:o.hitRadius?o.hitRadius:d.valueAtIndexOrDefault(r.pointHitRadius,n,s.hitRadius)}}),e._model.skip=o.skip?o.skip:isNaN(e._model.x)||isNaN(e._model.y)},updateBezierControlPoints:function t(){var a=this.chart.chartArea,o=this.getMeta();d.each(o.data,function(t,e){var n=t._model,i=d.splineCurve(d.previousItem(o.data,e,!0)._model,n,d.nextItem(o.data,e,!0)._model,n.tension);// Prevent the bezier going outside of the bounds of the graph
n.controlPointPreviousX=Math.max(Math.min(i.previous.x,a.right),a.left),n.controlPointPreviousY=Math.max(Math.min(i.previous.y,a.bottom),a.top),n.controlPointNextX=Math.max(Math.min(i.next.x,a.right),a.left),n.controlPointNextY=Math.max(Math.min(i.next.y,a.bottom),a.top),// Now pivot the point for animation
t.pivot()})},setHoverStyle:function t(e){
// Point
var n=this.chart.data.datasets[e._datasetIndex],i=e.custom||{},a=e._index,o=e._model;e.$previousStyle={backgroundColor:o.backgroundColor,borderColor:o.borderColor,borderWidth:o.borderWidth,radius:o.radius},o.radius=i.hoverRadius?i.hoverRadius:d.valueAtIndexOrDefault(n.pointHoverRadius,a,this.chart.options.elements.point.hoverRadius),o.backgroundColor=i.hoverBackgroundColor?i.hoverBackgroundColor:d.valueAtIndexOrDefault(n.pointHoverBackgroundColor,a,d.getHoverColor(o.backgroundColor)),o.borderColor=i.hoverBorderColor?i.hoverBorderColor:d.valueAtIndexOrDefault(n.pointHoverBorderColor,a,d.getHoverColor(o.borderColor)),o.borderWidth=i.hoverBorderWidth?i.hoverBorderWidth:d.valueAtIndexOrDefault(n.pointHoverBorderWidth,a,o.borderWidth)}})}},{26:26,41:41,46:46}],21:[function(t,e,n){var i;t(26)._set("scatter",{hover:{mode:"single"},scales:{xAxes:[{id:"x-axis-1",
// need an ID so datasets can reference the scale
type:"linear",
// scatter should not use a category axis
position:"bottom"}],yAxes:[{id:"y-axis-1",type:"linear",position:"left"}]},showLines:!1,tooltips:{callbacks:{title:function t(){return"";// doesn't make sense for scatter since data are formatted as a point
},label:function t(e){return"("+e.xLabel+", "+e.yLabel+")"}}}}),e.exports=function(t){
// Scatter charts use line controllers
t.controllers.scatter=t.controllers.line}},{26:26}],22:[function(t,e,n){var i=t(27),n=e.exports=i.extend({chart:null,
// the animation associated chart instance
currentStep:0,
// the current animation step
numSteps:60,
// default number of steps
easing:"",
// the easing to use for this animation
render:null,
// render function used by the animation service
onAnimationProgress:null,
// user specified callback to fire on each step of the animation
onAnimationComplete:null});// DEPRECATIONS
/**
       * Provided for backward compatibility, use Chart.Animation instead
       * @prop Chart.Animation#animationObject
       * @deprecated since version 2.6.0
       * @todo remove at version 3
       */
Object.defineProperty(n.prototype,"animationObject",{get:function t(){return this}}),
/**
       * Provided for backward compatibility, use Chart.Animation#chart instead
       * @prop Chart.Animation#chartInstance
       * @deprecated since version 2.6.0
       * @todo remove at version 3
       */
Object.defineProperty(n.prototype,"chartInstance",{get:function t(){return this.chart},set:function t(e){this.chart=e}})},{27:27}],23:[function(t,e,n){var i=t(26),r=t(46);i._set("global",{animation:{duration:1e3,easing:"easeOutQuart",onProgress:r.noop,onComplete:r.noop}}),e.exports={frameDuration:17,animations:[],dropFrames:0,request:null,
/**
         * @param {Chart} chart - The chart to animate.
         * @param {Chart.Animation} animation - The animation that we will animate.
         * @param {Number} duration - The animation duration in ms.
         * @param {Boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions
         */
addAnimation:function t(e,n,i,a){var o=this.animations,r,l;for(n.chart=e,a||(e.animating=!0),r=0,l=o.length;r<l;++r)if(o[r].chart===e)return void(o[r]=n);o.push(n),// If there are no animations queued, manually kickstart a digest, for lack of a better word
1===o.length&&this.requestAnimationFrame()},cancelAnimation:function t(e){var n=r.findIndex(this.animations,function(t){return t.chart===e});-1!==n&&(this.animations.splice(n,1),e.animating=!1)},requestAnimationFrame:function t(){var e=this;null===e.request&&(
// Skip animation frame requests until the active one is executed.
// This can happen when processing mouse events, e.g. 'mousemove'
// and 'mouseout' events will trigger multiple renders.
e.request=r.requestAnimFrame.call(window,function(){e.request=null,e.startDigest()}))},
/**
         * @private
         */
startDigest:function t(){var e=this,n=Date.now(),i=0;1<e.dropFrames&&(i=Math.floor(e.dropFrames),e.dropFrames=e.dropFrames%1),e.advance(1+i);var a=Date.now();e.dropFrames+=(a-n)/e.frameDuration,// Do we have more stuff to animate?
0<e.animations.length&&e.requestAnimationFrame()},
/**
         * @private
         */
advance:function t(e){for(var n=this.animations,i,a,o=0;o<n.length;)a=(i=n[o]).chart,i.currentStep=(i.currentStep||0)+e,i.currentStep=Math.min(i.currentStep,i.numSteps),r.callback(i.render,[a,i],a),r.callback(i.onAnimationProgress,[i],a),i.currentStep>=i.numSteps?(r.callback(i.onAnimationComplete,[i],a),a.animating=!1,n.splice(o,1)):++o}}},{26:26,46:46}],24:[function(t,e,n){var c=t(22),h=t(23),i=t(26),f=t(46),r=t(29),a=t(31),g=t(49),p=t(32),m=t(34),l=t(36);e.exports=function(s){
/**
         * Initializes the given config with global and chart default values.
         */
function u(t){// Do NOT use configMerge() for the data object because this method merges arrays
// and so would change references to labels and datasets, preventing data updates.
var e=(t=t||{}).data=t.data||{};return e.datasets=e.datasets||[],e.labels=e.labels||[],t.options=f.configMerge(i.global,i[t.type],t.options||{}),t}
/**
         * Updates the config of the chart
         * @param chart {Chart} chart to update the options for
         */function o(e){var t=e.options;f.each(e.scales,function(t){a.removeBox(e,t)}),t=f.configMerge(s.defaults.global,s.defaults[e.config.type],t),e.options=e.config.options=t,e.ensureScalesHaveIDs(),e.buildOrUpdateScales(),// Tooltip
e.tooltip._options=t.tooltips,e.tooltip.initialize()}function d(t){return"top"===t||"bottom"===t}
// Create a dictionary of chart types, to allow for extension of existing types
s.types={},// Store a reference to each instance - allowing us to globally resize chart instances on window resize.
// Destroy method on the chart will remove the instance of the chart from this reference.
s.instances={},// Controllers available for dataset visualization eg. bar, line, slice, etc.
s.controllers={},f.extend(s.prototype,
/** @lends Chart */
{
/**
           * @private
           */
construct:function t(e,n){var i=this;n=u(n);var a=g.acquireContext(e,n),o=a&&a.canvas,r=o&&o.height,l=o&&o.width;i.id=f.uid(),i.ctx=a,i.canvas=o,i.config=n,i.width=l,i.height=r,i.aspectRatio=r?l/r:null,i.options=n.options,i._bufferedRender=!1,(
/**
             * Provided for backward compatibility, Chart and Chart.Controller have been merged,
             * the "instance" still need to be defined since it might be called from plugins.
             * @prop Chart#chart
             * @deprecated since version 2.6.0
             * @todo remove at version 3
             * @private
             */
i.chart=i).controller=i,// chart.chart.controller #inception
// Add the chart instance to the global namespace
s.instances[i.id]=i,// Define alias to the config data: `chart.data === chart.config.data`
Object.defineProperty(i,"data",{get:function t(){return i.config.data},set:function t(e){i.config.data=e}}),a&&o?(i.initialize(),i.update()):
// The given item is not a compatible context2d element, let's return before finalizing
// the chart initialization but after setting basic chart / controller properties that
// can help to figure out that the chart is not valid (e.g chart.canvas !== null);
// https://github.com/chartjs/Chart.js/issues/2807
console.error("Failed to create chart: can't acquire context from the given item")},
/**
           * @private
           */
initialize:function t(){var e=this;// Before init plugin notification
return p.notify(e,"beforeInit"),f.retinaScale(e,e.options.devicePixelRatio),e.bindEvents(),e.options.responsive&&
// Initial resize before chart draws (must be silent to preserve initial animations).
e.resize(!0),// Make sure scales have IDs and are built before we build any controllers.
e.ensureScalesHaveIDs(),e.buildOrUpdateScales(),e.initToolTip(),// After init plugin notification
p.notify(e,"afterInit"),e},clear:function t(){return f.canvas.clear(this),this},stop:function t(){
// Stops any current animation loop occurring
return h.cancelAnimation(this),this},resize:function t(e){var n=this,i=n.options,a=n.canvas,o=i.maintainAspectRatio&&n.aspectRatio||null,r=Math.max(0,Math.floor(f.getMaximumWidth(a))),l=Math.max(0,Math.floor(o?r/o:f.getMaximumHeight(a)));if((n.width!==r||n.height!==l)&&(a.width=n.width=r,a.height=n.height=l,a.style.width=r+"px",a.style.height=l+"px",f.retinaScale(n,i.devicePixelRatio),!e)){
// Notify any plugins about the resize
var s={width:r,height:l};p.notify(n,"resize",[s]),// Notify of resize
n.options.onResize&&n.options.onResize(n,s),n.stop(),n.update({duration:n.options.responsiveAnimationDuration})}},ensureScalesHaveIDs:function t(){var e=this.options,n=e.scales||{},i=e.scale;f.each(n.xAxes,function(t,e){t.id=t.id||"x-axis-"+e}),f.each(n.yAxes,function(t,e){t.id=t.id||"y-axis-"+e}),i&&(i.id=i.id||"scale")},
/**
           * Builds a map of scale ID to scale object for future lookup.
           */
buildOrUpdateScales:function t(){var r=this,e=r.options,l=r.scales||{},n=[],s=Object.keys(l).reduce(function(t,e){return t[e]=!1,t},{});e.scales&&(n=n.concat((e.scales.xAxes||[]).map(function(t){return{options:t,dtype:"category",dposition:"bottom"}}),(e.scales.yAxes||[]).map(function(t){return{options:t,dtype:"linear",dposition:"left"}}))),e.scale&&n.push({options:e.scale,dtype:"radialLinear",isDefault:!0,dposition:"chartArea"}),f.each(n,function(t){var e=t.options,n=e.id,i=f.valueOrDefault(e.type,t.dtype);d(e.position)!==d(t.dposition)&&(e.position=t.dposition),s[n]=!0;var a=null;if(n in l&&l[n].type===i)(a=l[n]).options=e,a.ctx=r.ctx,a.chart=r;else{var o=m.getScaleConstructor(i);if(!o)return;a=new o({id:n,type:i,options:e,ctx:r.ctx,chart:r}),l[a.id]=a}a.mergeTicksOptions(),// TODO(SB): I think we should be able to remove this custom case (options.scale)
// and consider it as a regular scale part of the "scales"" map only! This would
// make the logic easier and remove some useless? custom code.
t.isDefault&&(r.scale=a)}),// clear up discarded scales
f.each(s,function(t,e){t||delete l[e]}),r.scales=l,m.addScalesToLayout(this)},buildOrUpdateControllers:function t(){var o=this,r=[],l=[];return f.each(o.data.datasets,function(t,e){var n=o.getDatasetMeta(e),i=t.type||o.config.type;if(n.type&&n.type!==i&&(o.destroyDatasetMeta(e),n=o.getDatasetMeta(e)),n.type=i,r.push(n.type),n.controller)n.controller.updateIndex(e),n.controller.linkScales();else{var a=s.controllers[n.type];if(void 0===a)throw new Error('"'+n.type+'" is not a chart type.');n.controller=new a(o,e),l.push(n.controller)}},o),l},
/**
           * Reset the elements of all datasets
           * @private
           */
resetElements:function t(){var n=this;f.each(n.data.datasets,function(t,e){n.getDatasetMeta(e).controller.reset()},n)},
/**
          * Resets the chart back to it's state before the initial animation
          */
reset:function t(){this.resetElements(),this.tooltip.initialize()},update:function t(e,n){var i=this;if(e&&"object"===_typeof(e)||(
// backwards compatibility
e={duration:e,lazy:n}),o(i),// plugins options references might have change, let's invalidate the cache
// https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167
p._invalidate(i),!1!==p.notify(i,"beforeUpdate")){// In case the entire data object changed
i.tooltip._data=i.data;// Make sure dataset controllers are updated and new controllers are reset
var a=i.buildOrUpdateControllers();// Make sure all dataset controllers have correct meta data counts
f.each(i.data.datasets,function(t,e){i.getDatasetMeta(e).controller.buildOrUpdateElements()},i),i.updateLayout(),// Can only reset the new controllers after the scales have been updated
i.options.animation&&i.options.animation.duration&&f.each(a,function(t){t.reset()}),i.updateDatasets(),// Need to reset tooltip in case it is displayed with elements that are removed
// after update.
i.tooltip.initialize(),// Last active contains items that were previously in the tooltip.
// When we reset the tooltip, we need to clear it
i.lastActive=[],// Do this before render so that any plugins that need final scale updates can use it
p.notify(i,"afterUpdate"),i._bufferedRender?i._bufferedRequest={duration:e.duration,easing:e.easing,lazy:e.lazy}:i.render(e)}},
/**
           * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`
           * hook, in which case, plugins will not be called on `afterLayout`.
           * @private
           */
updateLayout:function t(){var e=this;!1!==p.notify(e,"beforeLayout")&&(a.update(this,this.width,this.height),
/**
             * Provided for backward compatibility, use `afterLayout` instead.
             * @method IPlugin#afterScaleUpdate
             * @deprecated since version 2.5.0
             * @todo remove at version 3
             * @private
             */
p.notify(e,"afterScaleUpdate"),p.notify(e,"afterLayout"))},
/**
           * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`
           * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.
           * @private
           */
updateDatasets:function t(){var e=this;if(!1!==p.notify(e,"beforeDatasetsUpdate")){for(var n=0,i=e.data.datasets.length;n<i;++n)e.updateDataset(n);p.notify(e,"afterDatasetsUpdate")}},
/**
           * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`
           * hook, in which case, plugins will not be called on `afterDatasetUpdate`.
           * @private
           */
updateDataset:function t(e){var n=this,i=n.getDatasetMeta(e),a={meta:i,index:e};!1!==p.notify(n,"beforeDatasetUpdate",[a])&&(i.controller.update(),p.notify(n,"afterDatasetUpdate",[a]))},render:function t(e,n){var i=this;e&&"object"===_typeof(e)||(
// backwards compatibility
e={duration:e,lazy:n});var a=e.duration,o=e.lazy;if(!1!==p.notify(i,"beforeRender")){var r=i.options.animation,l=function t(e){p.notify(i,"afterRender"),f.callback(r&&r.onComplete,[e],i)};if(r&&(void 0!==a&&0!==a||void 0===a&&0!==r.duration)){var s=new c({numSteps:(a||r.duration)/16.66,
// 60 fps
easing:e.easing||r.easing,render:function t(e,n){var i=f.easing.effects[n.easing],a=n.currentStep,o=a/n.numSteps;e.draw(i(o),o,a)},onAnimationProgress:r.onProgress,onAnimationComplete:l});h.addAnimation(i,s,a,o)}else i.draw(),// See https://github.com/chartjs/Chart.js/issues/3781
l(new c({numSteps:0,chart:i}));return i}},draw:function t(e){var n=this;n.clear(),f.isNullOrUndef(e)&&(e=1),n.transition(e),n.width<=0||n.height<=0||!1!==p.notify(n,"beforeDraw",[e])&&(// Draw all the scales
f.each(n.boxes,function(t){t.draw(n.chartArea)},n),n.scale&&n.scale.draw(),n.drawDatasets(e),n._drawTooltip(e),p.notify(n,"afterDraw",[e]))},
/**
           * @private
           */
transition:function t(e){for(var n=this,i=0,a=(n.data.datasets||[]).length;i<a;++i)n.isDatasetVisible(i)&&n.getDatasetMeta(i).controller.transition(e);n.tooltip.transition(e)},
/**
           * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`
           * hook, in which case, plugins will not be called on `afterDatasetsDraw`.
           * @private
           */
drawDatasets:function t(e){var n=this;if(!1!==p.notify(n,"beforeDatasetsDraw",[e])){// Draw datasets reversed to support proper line stacking
for(var i=(n.data.datasets||[]).length-1;0<=i;--i)n.isDatasetVisible(i)&&n.drawDataset(i,e);p.notify(n,"afterDatasetsDraw",[e])}},
/**
           * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`
           * hook, in which case, plugins will not be called on `afterDatasetDraw`.
           * @private
           */
drawDataset:function t(e,n){var i=this,a=i.getDatasetMeta(e),o={meta:a,index:e,easingValue:n};!1!==p.notify(i,"beforeDatasetDraw",[o])&&(a.controller.draw(n),p.notify(i,"afterDatasetDraw",[o]))},
/**
           * Draws tooltip unless a plugin returns `false` to the `beforeTooltipDraw`
           * hook, in which case, plugins will not be called on `afterTooltipDraw`.
           * @private
           */
_drawTooltip:function t(e){var n=this,i=n.tooltip,a={tooltip:i,easingValue:e};!1!==p.notify(n,"beforeTooltipDraw",[a])&&(i.draw(),p.notify(n,"afterTooltipDraw",[a]))},
// Get the single element that was clicked on
// @return : An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw
getElementAtEvent:function t(e){return r.modes.single(this,e)},getElementsAtEvent:function t(e){return r.modes.label(this,e,{intersect:!0})},getElementsAtXAxis:function t(e){return r.modes["x-axis"](this,e,{intersect:!0})},getElementsAtEventForMode:function t(e,n,i){var a=r.modes[n];return"function"==typeof a?a(this,e,i):[]},getDatasetAtEvent:function t(e){return r.modes.dataset(this,e,{intersect:!0})},getDatasetMeta:function t(e){var n=this,i=n.data.datasets[e];i._meta||(i._meta={});var a=i._meta[n.id];return a||(a=i._meta[n.id]={type:null,data:[],dataset:null,controller:null,hidden:null,
// See isDatasetVisible() comment
xAxisID:null,yAxisID:null}),a},getVisibleDatasetCount:function t(){for(var e=0,n=0,i=this.data.datasets.length;n<i;++n)this.isDatasetVisible(n)&&e++;return e},isDatasetVisible:function t(e){var n=this.getDatasetMeta(e);// meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,
// the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.
return"boolean"==typeof n.hidden?!n.hidden:!this.data.datasets[e].hidden},generateLegend:function t(){return this.options.legendCallback(this)},
/**
           * @private
           */
destroyDatasetMeta:function t(e){var n=this.id,i=this.data.datasets[e],a=i._meta&&i._meta[n];a&&(a.controller.destroy(),delete i._meta[n])},destroy:function t(){var e=this,n=e.canvas,i,a;// dataset controllers need to cleanup associated data
for(e.stop(),i=0,a=e.data.datasets.length;i<a;++i)e.destroyDatasetMeta(i);n&&(e.unbindEvents(),f.canvas.clear(e),g.releaseContext(e.ctx),e.canvas=null,e.ctx=null),p.notify(e,"destroy"),delete s.instances[e.id]},toBase64Image:function t(){return this.canvas.toDataURL.apply(this.canvas,arguments)},initToolTip:function t(){var e=this;e.tooltip=new l({_chart:e,_chartInstance:e,
// deprecated, backward compatibility
_data:e.data,_options:e.options.tooltips},e)},
/**
           * @private
           */
bindEvents:function t(){var e=this,n=e._listeners={},i=function t(){e.eventHandler.apply(e,arguments)};f.each(e.options.events,function(t){g.addEventListener(e,t,i),n[t]=i}),// Elements used to detect size change should not be injected for non responsive charts.
// See https://github.com/chartjs/Chart.js/issues/2210
e.options.responsive&&(i=function t(){e.resize()},g.addEventListener(e,"resize",i),n.resize=i)},
/**
           * @private
           */
unbindEvents:function t(){var n=this,e=n._listeners;e&&(delete n._listeners,f.each(e,function(t,e){g.removeEventListener(n,e,t)}))},updateHoverStyle:function t(e,n,i){var a=i?"setHoverStyle":"removeHoverStyle",o,r,l;for(r=0,l=e.length;r<l;++r)(o=e[r])&&this.getDatasetMeta(o._datasetIndex).controller[a](o)},
/**
           * @private
           */
eventHandler:function t(e){var n=this,i=n.tooltip;if(!1!==p.notify(n,"beforeEvent",[e])){// Buffer any update calls so that renders do not occur
n._bufferedRender=!0,n._bufferedRequest=null;var a=n.handleEvent(e);// for smooth tooltip animations issue #4989
// the tooltip should be the source of change
// Animation check workaround:
// tooltip._start will be null when tooltip isn't animating
i&&(a=i._start?i.handleEvent(e):a|i.handleEvent(e)),p.notify(n,"afterEvent",[e]);var o=n._bufferedRequest;return o?
// If we have an update that was triggered, we need to do a normal render
n.render(o):a&&!n.animating&&(
// If entering, leaving, or changing elements, animate the change via pivot
n.stop(),// We only need to render at this point. Updating will cause scales to be
// recomputed generating flicker & using more memory than necessary.
n.render({duration:n.options.hover.animationDuration,lazy:!0})),n._bufferedRender=!1,n._bufferedRequest=null,n}},
/**
           * Handle an event
           * @private
           * @param {IEvent} event the event to handle
           * @return {Boolean} true if the chart needs to re-render
           */
handleEvent:function t(e){var n=this,i=n.options||{},a=i.hover,o=!1;return n.lastActive=n.lastActive||[],// Find Active Elements for hover and tooltips
"mouseout"===e.type?n.active=[]:n.active=n.getElementsAtEventForMode(e,a.mode,a),// Invoke onHover hook
// Need to call with native event here to not break backwards compatibility
f.callback(i.onHover||i.hover.onHover,[e.native,n.active],n),"mouseup"!==e.type&&"click"!==e.type||i.onClick&&
// Use e.native here for backwards compatibility
i.onClick.call(n,e.native,n.active),// Remove styling for last active (even if it may still be active)
n.lastActive.length&&n.updateHoverStyle(n.lastActive,a.mode,!1),// Built in hover styling
n.active.length&&a.mode&&n.updateHoverStyle(n.active,a.mode,!0),o=!f.arrayEquals(n.active,n.lastActive),// Remember Last Actives
n.lastActive=n.active,o}}),
/**
         * Provided for backward compatibility, use Chart instead.
         * @class Chart.Controller
         * @deprecated since version 2.6.0
         * @todo remove at version 3
         * @private
         */
s.Controller=s}},{22:22,23:23,26:26,29:29,31:31,32:32,34:34,36:36,46:46,49:49}],25:[function(t,e,n){var s=t(46);e.exports=function(t){
/**
         * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',
         * 'unshift') and notify the listener AFTER the array has been altered. Listeners are
         * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.
         */
function a(o,t){o._chartjs?o._chartjs.listeners.push(t):(Object.defineProperty(o,"_chartjs",{configurable:!0,enumerable:!1,value:{listeners:[t]}}),r.forEach(function(t){var i="onData"+t.charAt(0).toUpperCase()+t.slice(1),a=o[t];Object.defineProperty(o,t,{configurable:!0,enumerable:!1,value:function t(){var e=Array.prototype.slice.call(arguments),n=a.apply(this,e);return s.each(o._chartjs.listeners,function(t){"function"==typeof t[i]&&t[i].apply(t,e)}),n}})}))}
/**
         * Removes the given array event listener and cleanup extra attached properties (such as
         * the _chartjs stub and overridden methods) if array doesn't have any more listeners.
         */function o(e,t){var n=e._chartjs;if(n){var i=n.listeners,a=i.indexOf(t);-1!==a&&i.splice(a,1),0<i.length||(r.forEach(function(t){delete e[t]}),delete e._chartjs)}}// Base class for all dataset controllers (line, bar, etc)
var r=["push","pop","shift","splice","unshift"];t.DatasetController=function(t,e){this.initialize(t,e)},s.extend(t.DatasetController.prototype,{
/**
           * Element type used to generate a meta dataset (e.g. Chart.element.Line).
           * @type {Chart.core.element}
           */
datasetElementType:null,
/**
           * Element type used to generate a meta data (e.g. Chart.element.Point).
           * @type {Chart.core.element}
           */
dataElementType:null,initialize:function t(e,n){var i=this;i.chart=e,i.index=n,i.linkScales(),i.addElements()},updateIndex:function t(e){this.index=e},linkScales:function t(){var e=this,n=e.getMeta(),i=e.getDataset();null!==n.xAxisID&&n.xAxisID in e.chart.scales||(n.xAxisID=i.xAxisID||e.chart.options.scales.xAxes[0].id),null!==n.yAxisID&&n.yAxisID in e.chart.scales||(n.yAxisID=i.yAxisID||e.chart.options.scales.yAxes[0].id)},getDataset:function t(){return this.chart.data.datasets[this.index]},getMeta:function t(){return this.chart.getDatasetMeta(this.index)},getScaleForId:function t(e){return this.chart.scales[e]},reset:function t(){this.update(!0)},
/**
           * @private
           */
destroy:function t(){this._data&&o(this._data,this)},createMetaDataset:function t(){var e=this,n=e.datasetElementType;return n&&new n({_chart:e.chart,_datasetIndex:e.index})},createMetaData:function t(e){var n=this,i=n.dataElementType;return i&&new i({_chart:n.chart,_datasetIndex:n.index,_index:e})},addElements:function t(){var e=this,n=e.getMeta(),i=e.getDataset().data||[],a=n.data,o,r;for(o=0,r=i.length;o<r;++o)a[o]=a[o]||e.createMetaData(o);n.dataset=n.dataset||e.createMetaDataset()},addElementAndReset:function t(e){var n=this.createMetaData(e);this.getMeta().data.splice(e,0,n),this.updateElement(n,e,!0)},buildOrUpdateElements:function t(){var e=this,n=e.getDataset(),i=n.data||(n.data=[]);// In order to correctly handle data addition/deletion animation (an thus simulate
// real-time charts), we need to monitor these data modifications and synchronize
// the internal meta data accordingly.
e._data!==i&&(e._data&&
// This case happens when the user replaced the data array instance.
o(e._data,e),a(i,e),e._data=i),// Re-sync meta data in case the user replaced the data array or if we missed
// any updates and so make sure that we handle number of datapoints changing.
e.resyncElements()},update:s.noop,transition:function t(e){for(var n=this.getMeta(),i=n.data||[],a=i.length,o=0;o<a;++o)i[o].transition(e);n.dataset&&n.dataset.transition(e)},draw:function t(){var e=this.getMeta(),n=e.data||[],i=n.length,a=0;for(e.dataset&&e.dataset.draw();a<i;++a)n[a].draw()},removeHoverStyle:function t(e){s.merge(e._model,e.$previousStyle||{}),delete e.$previousStyle},setHoverStyle:function t(e){var n=this.chart.data.datasets[e._datasetIndex],i=e._index,a=e.custom||{},o=s.valueAtIndexOrDefault,r=s.getHoverColor,l=e._model;e.$previousStyle={backgroundColor:l.backgroundColor,borderColor:l.borderColor,borderWidth:l.borderWidth},l.backgroundColor=a.hoverBackgroundColor?a.hoverBackgroundColor:o(n.hoverBackgroundColor,i,r(l.backgroundColor)),l.borderColor=a.hoverBorderColor?a.hoverBorderColor:o(n.hoverBorderColor,i,r(l.borderColor)),l.borderWidth=a.hoverBorderWidth?a.hoverBorderWidth:o(n.hoverBorderWidth,i,l.borderWidth)},
/**
           * @private
           */
resyncElements:function t(){var e=this,n=e.getMeta(),i=e.getDataset().data,a=n.data.length,o=i.length;o<a?n.data.splice(o,a-o):a<o&&e.insertElements(a,o-a)},
/**
           * @private
           */
insertElements:function t(e,n){for(var i=0;i<n;++i)this.addElementAndReset(e+i)},
/**
           * @private
           */
onDataPush:function t(){this.insertElements(this.getDataset().data.length-1,arguments.length)},
/**
           * @private
           */
onDataPop:function t(){this.getMeta().data.pop()},
/**
           * @private
           */
onDataShift:function t(){this.getMeta().data.shift()},
/**
           * @private
           */
onDataSplice:function t(e,n){this.getMeta().data.splice(e,n),this.insertElements(e,arguments.length-2)},
/**
           * @private
           */
onDataUnshift:function t(){this.insertElements(0,arguments.length)}}),t.DatasetController.extend=s.inherits}},{46:46}],26:[function(t,e,n){var i=t(46);e.exports={
/**
         * @private
         */
_set:function t(e,n){return i.merge(this[e]||(this[e]={}),n)}}},{46:46}],27:[function(t,e,n){function r(t,e,n,i){var a=Object.keys(n),o,r,l,s,u,d,c,h,f;for(o=0,r=a.length;o<r;++o)if(d=n[l=a[o]],// if a value is added to the model after pivot() has been called, the view
// doesn't contain it, so let's initialize the view to the target value.
e.hasOwnProperty(l)||(e[l]=d),(s=e[l])!==d&&"_"!==l[0]){if(t.hasOwnProperty(l)||(t[l]=s),u=t[l],(c=_typeof(d))===_typeof(u))if("string"===c){if((h=g(u)).valid&&(f=g(d)).valid){e[l]=f.mix(h,i).rgbString();continue}}else if("number"===c&&isFinite(u)&&isFinite(d)){e[l]=u+(d-u)*i;continue}e[l]=d}}var g=t(3),i=t(46),a=function t(e){i.extend(this,e),this.initialize.apply(this,arguments)};i.extend(a.prototype,{initialize:function t(){this.hidden=!1},pivot:function t(){var e=this;return e._view||(e._view=i.clone(e._model)),e._start={},e},transition:function t(e){var n=this,i=n._model,a=n._start,o=n._view;// No animation -> No Transition
return i&&1!==e?(o||(o=n._view={}),a||(a=n._start={}),r(a,o,i,e)):(n._view=i,n._start=null),n},tooltipPosition:function t(){return{x:this._model.x,y:this._model.y}},hasValue:function t(){return i.isNumber(this._model.x)&&i.isNumber(this._model.y)}}),a.extend=i.inherits,e.exports=a},{3:3,46:46}],28:[function(t,e,n){var i=t(3),a=t(26),g=t(46),u=t(34);e.exports=function(){// Private helper function to convert max-width/max-height values that may be percentages into a number
function d(t,e,n){var i;return"string"==typeof t?(i=parseInt(t,10),-1!==t.indexOf("%")&&(
// percentage * size in dimension
i=i/100*e.parentNode[n])):i=t,i}
/**
         * Returns if the given value contains an effective constraint.
         * @private
         */function c(t){return null!=t&&"none"!==t}// Private helper to get a constraint dimension
// @param domNode : the node to check the constraint on
// @param maxStyle : the style that defines the maximum for the direction we are using (maxWidth / maxHeight)
// @param percentageProperty : property of parent to use when calculating width as a percentage
// @see http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser
function e(t,e,n){var i=document.defaultView,a=g._getParentNode(t),o=i.getComputedStyle(t)[e],r=i.getComputedStyle(a)[e],l=c(o),s=c(r),u=Number.POSITIVE_INFINITY;return l||s?Math.min(l?d(o,t,n):u,s?d(r,a,n):u):"none"}// returns Number or undefined if no constraint
// -- Basic js utility methods
g.configMerge=function(t){return g.merge(g.clone(t),[].slice.call(arguments,1),{merger:function t(e,n,i,a){var o=n[e]||{},r=i[e];"scales"===e?
// scale config merging is complex. Add our own function here for that
n[e]=g.scaleMerge(o,r):"scale"===e?
// used in polar area & radar charts since there is only one scale
n[e]=g.merge(o,[u.getScaleDefaults(r.type),r]):g._merger(e,n,i,a)}})},g.scaleMerge=function(t){return g.merge(g.clone(t),[].slice.call(arguments,1),{merger:function t(e,n,i,a){if("xAxes"===e||"yAxes"===e){var o=i[e].length,r,l,s;for(n[e]||(n[e]=[]),r=0;r<o;++r)s=i[e][r],l=g.valueOrDefault(s.type,"xAxes"===e?"category":"linear"),r>=n[e].length&&n[e].push({}),!n[e][r].type||s.type&&s.type!==n[e][r].type?
// new/untyped scale or type changed: let's apply the new defaults
// then merge source scale to correctly overwrite the defaults.
g.merge(n[e][r],[u.getScaleDefaults(l),s]):
// scales type are the same
g.merge(n[e][r],s)}else g._merger(e,n,i,a)}})},g.where=function(t,e){if(g.isArray(t)&&Array.prototype.filter)return t.filter(e);var n=[];return g.each(t,function(t){e(t)&&n.push(t)}),n},g.findIndex=Array.prototype.findIndex?function(t,e,n){return t.findIndex(e,n)}:function(t,e,n){n=void 0===n?t:n;for(var i=0,a=t.length;i<a;++i)if(e.call(n,t[i],i,t))return i;return-1},g.findNextWhere=function(t,e,n){
// Default to start of the array
g.isNullOrUndef(n)&&(n=-1);for(var i=n+1;i<t.length;i++){var a=t[i];if(e(a))return a}},g.findPreviousWhere=function(t,e,n){
// Default to end of the array
g.isNullOrUndef(n)&&(n=t.length);for(var i=n-1;0<=i;i--){var a=t[i];if(e(a))return a}},// -- Math methods
g.isNumber=function(t){return!isNaN(parseFloat(t))&&isFinite(t)},g.almostEquals=function(t,e,n){return Math.abs(t-e)<n},g.almostWhole=function(t,e){var n=Math.round(t);return n-e<t&&t<n+e},g.max=function(t){return t.reduce(function(t,e){return isNaN(e)?t:Math.max(t,e)},Number.NEGATIVE_INFINITY)},g.min=function(t){return t.reduce(function(t,e){return isNaN(e)?t:Math.min(t,e)},Number.POSITIVE_INFINITY)},g.sign=Math.sign?function(t){return Math.sign(t)}:function(t){// convert to a number
return 0===(t=+t)||isNaN(t)?t:0<t?1:-1},g.log10=Math.log10?function(t){return Math.log10(t)}:function(t){var e=Math.log(t)*Math.LOG10E,n=Math.round(e),i;// Math.LOG10E = 1 / Math.LN10.
// Check for whole powers of 10,
// which due to floating point rounding error should be corrected.
return t===Math.pow(10,n)?n:e},g.toRadians=function(t){return t*(Math.PI/180)},g.toDegrees=function(t){return t*(180/Math.PI)},// Gets the angle from vertical upright to the point about a centre.
g.getAngleFromPoint=function(t,e){var n=e.x-t.x,i=e.y-t.y,a=Math.sqrt(n*n+i*i),o=Math.atan2(i,n);return o<-.5*Math.PI&&(o+=2*Math.PI),{angle:o,distance:a}},g.distanceBetweenPoints=function(t,e){return Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2))},g.aliasPixel=function(t){return t%2==0?0:.5},g.splineCurve=function(t,e,n,i){
// Props to Rob Spencer at scaled innovation for his post on splining between points
// http://scaledinnovation.com/analytics/splines/aboutSplines.html
// This function must also respect "skipped" points
var a=t.skip?e:t,o=e,r=n.skip?e:n,l=Math.sqrt(Math.pow(o.x-a.x,2)+Math.pow(o.y-a.y,2)),s=Math.sqrt(Math.pow(r.x-o.x,2)+Math.pow(r.y-o.y,2)),u=l/(l+s),d=s/(l+s),c=i*(// If all points are the same, s01 & s02 will be inf
u=isNaN(u)?0:u),h=i*(d=isNaN(d)?0:d);return{previous:{x:o.x-c*(r.x-a.x),y:o.y-c*(r.y-a.y)},next:{x:o.x+h*(r.x-a.x),y:o.y+h*(r.y-a.y)}}},g.EPSILON=Number.EPSILON||1e-14,g.splineCurveMonotone=function(t){
// This function calculates Bzier control points in a similar way than |splineCurve|,
// but preserves monotonicity of the provided data and ensures no local extremums are added
// between the dataset discrete points due to the interpolation.
// See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation
var e=(t||[]).map(function(t){return{model:t._model,deltaK:0,mK:0}}),n=e.length,i,a,o,r,l,s,u,d,c;// Calculate slopes (deltaK) and initialize tangents (mK)
for(i=0;i<n;++i)if(!(o=e[i]).model.skip){if(a=0<i?e[i-1]:null,(r=i<n-1?e[i+1]:null)&&!r.model.skip){var h=r.model.x-o.model.x;// In the case of two points that appear at the same x pixel, slopeDeltaX is 0
o.deltaK=0!==h?(r.model.y-o.model.y)/h:0}!a||a.model.skip?o.mK=o.deltaK:!r||r.model.skip?o.mK=a.deltaK:this.sign(a.deltaK)!==this.sign(o.deltaK)?o.mK=0:o.mK=(a.deltaK+o.deltaK)/2}// Adjust tangents to ensure monotonic properties
for(i=0;i<n-1;++i)o=e[i],r=e[i+1],o.model.skip||r.model.skip||(g.almostEquals(o.deltaK,0,this.EPSILON)?o.mK=r.mK=0:(l=o.mK/o.deltaK,s=r.mK/o.deltaK,(d=Math.pow(l,2)+Math.pow(s,2))<=9||(u=3/Math.sqrt(d),o.mK=l*u*o.deltaK,r.mK=s*u*o.deltaK)));// Compute control points
for(i=0;i<n;++i)(o=e[i]).model.skip||(a=0<i?e[i-1]:null,r=i<n-1?e[i+1]:null,a&&!a.model.skip&&(c=(o.model.x-a.model.x)/3,o.model.controlPointPreviousX=o.model.x-c,o.model.controlPointPreviousY=o.model.y-c*o.mK),r&&!r.model.skip&&(c=(r.model.x-o.model.x)/3,o.model.controlPointNextX=o.model.x+c,o.model.controlPointNextY=o.model.y+c*o.mK))},g.nextItem=function(t,e,n){return n?e>=t.length-1?t[0]:t[e+1]:e>=t.length-1?t[t.length-1]:t[e+1]},g.previousItem=function(t,e,n){return n?e<=0?t[t.length-1]:t[e-1]:e<=0?t[0]:t[e-1]},// Implementation of the nice number algorithm used in determining where axis labels will go
g.niceNum=function(t,e){var n=Math.floor(g.log10(t)),i=t/Math.pow(10,n),a;return(a=e?i<1.5?1:i<3?2:i<7?5:10:i<=1?1:i<=2?2:i<=5?5:10)*Math.pow(10,n)},// Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
g.requestAnimFrame="undefined"==typeof window?function(t){t()}:window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(t){return window.setTimeout(t,1e3/60)},// -- DOM methods
g.getRelativePosition=function(t,e){var n,i,a=t.originalEvent||t,o=t.target||t.srcElement,r=o.getBoundingClientRect(),l=a.touches;i=l&&0<l.length?(n=l[0].clientX,l[0].clientY):(n=a.clientX,a.clientY);// Scale mouse coordinates into canvas coordinates
// by following the pattern laid out by 'jerryj' in the comments of
// http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/
var s=parseFloat(g.getStyle(o,"padding-left")),u=parseFloat(g.getStyle(o,"padding-top")),d=parseFloat(g.getStyle(o,"padding-right")),c=parseFloat(g.getStyle(o,"padding-bottom")),h=r.right-r.left-s-d,f=r.bottom-r.top-u-c;return{x:// We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However
// the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here
n=Math.round((n-r.left-s)/h*o.width/e.currentDevicePixelRatio),y:i=Math.round((i-r.top-u)/f*o.height/e.currentDevicePixelRatio)}},g.getConstraintWidth=function(t){return e(t,"max-width","clientWidth")},// returns Number or undefined if no constraint
g.getConstraintHeight=function(t){return e(t,"max-height","clientHeight")},
/**
         * @private
        	 */
g._calculatePadding=function(t,e,n){return-1<(e=g.getStyle(t,e)).indexOf("%")?n/parseInt(e,10):parseInt(e,10)},
/**
         * @private
         */
g._getParentNode=function(t){var e=t.parentNode;return e&&e.host&&(e=e.host),e},g.getMaximumWidth=function(t){var e=g._getParentNode(t);if(!e)return t.clientWidth;var n=e.clientWidth,i,a,o=n-g._calculatePadding(e,"padding-left",n)-g._calculatePadding(e,"padding-right",n),r=g.getConstraintWidth(t);return isNaN(r)?o:Math.min(o,r)},g.getMaximumHeight=function(t){var e=g._getParentNode(t);if(!e)return t.clientHeight;var n=e.clientHeight,i,a,o=n-g._calculatePadding(e,"padding-top",n)-g._calculatePadding(e,"padding-bottom",n),r=g.getConstraintHeight(t);return isNaN(r)?o:Math.min(o,r)},g.getStyle=function(t,e){return t.currentStyle?t.currentStyle[e]:document.defaultView.getComputedStyle(t,null).getPropertyValue(e)},g.retinaScale=function(t,e){var n=t.currentDevicePixelRatio=e||"undefined"!=typeof window&&window.devicePixelRatio||1;if(1!==n){var i=t.canvas,a=t.height,o=t.width;i.height=a*n,i.width=o*n,t.ctx.scale(n,n),// If no style has been set on the canvas, the render size is used as display size,
// making the chart visually bigger, so let's enforce it to the "correct" values.
// See https://github.com/chartjs/Chart.js/issues/3575
i.style.height||i.style.width||(i.style.height=a+"px",i.style.width=o+"px")}},// -- Canvas methods
g.fontString=function(t,e,n){return e+" "+t+"px "+n},g.longestText=function(e,t,n,i){var a=(i=i||{}).data=i.data||{},o=i.garbageCollect=i.garbageCollect||[];i.font!==t&&(a=i.data={},o=i.garbageCollect=[],i.font=t),e.font=t;var r=0;g.each(n,function(t){
// Undefined strings and arrays should not be measured
null!=t&&!0!==g.isArray(t)?r=g.measureText(e,a,o,r,t):g.isArray(t)&&
// if it is an array lets measure each element
// to do maybe simplify this function a bit so we can do this more recursively?
g.each(t,function(t){
// Undefined strings and arrays should not be measured
null==t||g.isArray(t)||(r=g.measureText(e,a,o,r,t))})});var l=o.length/2;if(l>n.length){for(var s=0;s<l;s++)delete a[o[s]];o.splice(0,l)}return r},g.measureText=function(t,e,n,i,a){var o=e[a];return o||(o=e[a]=t.measureText(a).width,n.push(a)),i<o&&(i=o),i},g.numberOfLabelLines=function(t){var e=1;return g.each(t,function(t){g.isArray(t)&&t.length>e&&(e=t.length)}),e},g.color=i?function(t){
/* global CanvasGradient */
return t instanceof CanvasGradient&&(t=a.global.defaultColor),i(t)}:function(t){return console.error("Color.js not found!"),t},g.getHoverColor=function(t){
/* global CanvasPattern */
return t instanceof CanvasPattern?t:g.color(t).saturate(.5).darken(.1).rgbString()}}},{26:26,3:3,34:34,46:46}],29:[function(t,e,n){
/**
       * Helper function to get relative position for an event
       * @param {Event|IEvent} event - The event to get the position for
       * @param {Chart} chart - The chart
       * @returns {Point} the event position
       */
function l(t,e){return t.native?{x:t.x,y:t.y}:a.getRelativePosition(t,e)}
/**
       * Helper function to traverse all of the visible elements in the chart
       * @param chart {chart} the chart
       * @param handler {Function} the callback to execute for each visible item
       */function s(t,e){var n,i,a,o,r,l;for(a=0,r=t.data.datasets.length;a<r;++a)if(t.isDatasetVisible(a))for(o=0,l=(i=t.getDatasetMeta(a)).data.length;o<l;++o){var s=i.data[o];s._view.skip||e(s)}}
/**
       * Helper function to get the items that intersect the event position
       * @param items {ChartElement[]} elements to filter
       * @param position {Point} the point to be nearest to
       * @return {ChartElement[]} the nearest items
       */function u(t,e){var n=[];return s(t,function(t){t.inRange(e.x,e.y)&&n.push(t)}),n}
/**
       * Helper function to get the items nearest to the event position considering all visible items in teh chart
       * @param chart {Chart} the chart to look at elements from
       * @param position {Point} the point to be nearest to
       * @param intersect {Boolean} if true, only consider items that intersect the position
       * @param distanceMetric {Function} function to provide the distance between points
       * @return {ChartElement[]} the nearest items
       */function d(t,i,a,o){var r=Number.POSITIVE_INFINITY,l=[];return s(t,function(t){if(!a||t.inRange(i.x,i.y)){var e=t.getCenterPoint(),n=o(i,e);n<r?(l=[t],r=n):n===r&&
// Can have multiple items at the same distance in which case we sort by size
l.push(t)}}),l}
/**
       * Get a distance metric function for two points based on the
       * axis mode setting
       * @param {String} axis the axis mode. x|y|xy
       */function c(t){var a=-1!==t.indexOf("x"),o=-1!==t.indexOf("y");return function(t,e){var n=a?Math.abs(t.x-e.x):0,i=o?Math.abs(t.y-e.y):0;return Math.sqrt(Math.pow(n,2)+Math.pow(i,2))}}function i(a,t,e){var n=l(t,a);// Default axis for index mode is 'x' to match old behaviour
e.axis=e.axis||"x";var i=c(e.axis),o=e.intersect?u(a,n):d(a,n,!1,i),r=[];return o.length?(a.data.datasets.forEach(function(t,e){if(a.isDatasetVisible(e)){var n,i=a.getDatasetMeta(e).data[o[0]._index];// don't count items that are skipped (null data)
i&&!i._view.skip&&r.push(i)}}),r):[]}
/**
       * @interface IInteractionOptions
       */
/**
       * If true, only consider items that intersect the point
       * @name IInterfaceOptions#boolean
       * @type Boolean
       */
/**
       * Contains interaction related functions
       * @namespace Chart.Interaction
       */var a=t(46);e.exports={
// Helper function for different modes
modes:{single:function t(e,n){var i=l(n,e),a=[];return s(e,function(t){if(t.inRange(i.x,i.y))return a.push(t),a}),a.slice(0,1)},
/**
           * @function Chart.Interaction.modes.label
           * @deprecated since version 2.4.0
           * @todo remove at version 3
           * @private
           */
label:i,
/**
           * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something
           * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item
           * @function Chart.Interaction.modes.index
           * @since v2.4.0
           * @param chart {chart} the chart we are returning items from
           * @param e {Event} the event we are find things at
           * @param options {IInteractionOptions} options to use during interaction
           * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
           */
index:i,
/**
           * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something
           * If the options.intersect is false, we find the nearest item and return the items in that dataset
           * @function Chart.Interaction.modes.dataset
           * @param chart {chart} the chart we are returning items from
           * @param e {Event} the event we are find things at
           * @param options {IInteractionOptions} options to use during interaction
           * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
           */
dataset:function t(e,n,i){var a=l(n,e);i.axis=i.axis||"xy";var o=c(i.axis),r=i.intersect?u(e,a):d(e,a,!1,o);return 0<r.length&&(r=e.getDatasetMeta(r[0]._datasetIndex).data),r},
/**
           * @function Chart.Interaction.modes.x-axis
           * @deprecated since version 2.4.0. Use index mode and intersect == true
           * @todo remove at version 3
           * @private
           */
"x-axis":function t(e,n){return i(e,n,{intersect:!1})},
/**
           * Point mode returns all elements that hit test based on the event position
           * of the event
           * @function Chart.Interaction.modes.intersect
           * @param chart {chart} the chart we are returning items from
           * @param e {Event} the event we are find things at
           * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
           */
point:function t(e,n){var i;return u(e,l(n,e))},
/**
           * nearest mode returns the element closest to the point
           * @function Chart.Interaction.modes.intersect
           * @param chart {chart} the chart we are returning items from
           * @param e {Event} the event we are find things at
           * @param options {IInteractionOptions} options to use
           * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
           */
nearest:function t(e,n,i){var a=l(n,e);i.axis=i.axis||"xy";var o=c(i.axis),r=d(e,a,i.intersect,o);// Return only 1 item
// We have multiple items at the same distance from the event. Now sort by smallest
return 1<r.length&&r.sort(function(t,e){var n,i,a=t.getArea()-e.getArea();return 0===a&&(
// if equal sort by dataset index
a=t._datasetIndex-e._datasetIndex),a}),r.slice(0,1)},
/**
           * x mode returns the elements that hit-test at the current x coordinate
           * @function Chart.Interaction.modes.x
           * @param chart {chart} the chart we are returning items from
           * @param e {Event} the event we are find things at
           * @param options {IInteractionOptions} options to use
           * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
           */
x:function t(e,n,i){var a=l(n,e),o=[],r=!1;return s(e,function(t){t.inXRange(a.x)&&o.push(t),t.inRange(a.x,a.y)&&(r=!0)}),// If we want to trigger on an intersect and we don't have any items
// that intersect the position, return nothing
i.intersect&&!r&&(o=[]),o},
/**
           * y mode returns the elements that hit-test at the current y coordinate
           * @function Chart.Interaction.modes.y
           * @param chart {chart} the chart we are returning items from
           * @param e {Event} the event we are find things at
           * @param options {IInteractionOptions} options to use
           * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
           */
y:function t(e,n,i){var a=l(n,e),o=[],r=!1;return s(e,function(t){t.inYRange(a.y)&&o.push(t),t.inRange(a.x,a.y)&&(r=!0)}),// If we want to trigger on an intersect and we don't have any items
// that intersect the position, return nothing
i.intersect&&!r&&(o=[]),o}}}},{46:46}],30:[function(t,e,n){var i;t(26)._set("global",{responsive:!0,responsiveAnimationDuration:0,maintainAspectRatio:!0,events:["mousemove","mouseout","click","touchstart","touchmove"],hover:{onHover:null,mode:"nearest",intersect:!0,animationDuration:400},onClick:null,defaultColor:"rgba(0,0,0,0.1)",defaultFontColor:"#666",defaultFontFamily:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",defaultFontSize:12,defaultFontStyle:"normal",showLines:!0,
// Element defaults defined in element extensions
elements:{},
// Layout options such as padding
layout:{padding:{top:0,right:0,bottom:0,left:0}}}),e.exports=function(){
// Occupy the global variable of Chart, and create a simple base class
var t=function t(e,n){return this.construct(e,n),this};return t.Chart=t}},{26:26}],31:[function(t,e,n){function H(t,e){return q.where(t,function(t){return t.position===e})}function j(t,a){t.forEach(function(t,e){return t._tmpIndex_=e,t}),t.sort(function(t,e){var n=a?e:t,i=a?t:e;return n.weight===i.weight?n._tmpIndex_-i._tmpIndex_:n.weight-i.weight}),t.forEach(function(t){delete t._tmpIndex_})}
/**
       * @interface ILayoutItem
       * @prop {String} position - The position of the item in the chart layout. Possible values are
       * 'left', 'top', 'right', 'bottom', and 'chartArea'
       * @prop {Number} weight - The weight used to sort the item. Higher weights are further away from the chart area
       * @prop {Boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down
       * @prop {Function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)
       * @prop {Function} update - Takes two parameters: width and height. Returns size of item
       * @prop {Function} getPadding -  Returns an object with padding on the edges
       * @prop {Number} width - Width of item. Must be valid after update()
       * @prop {Number} height - Height of item. Must be valid after update()
       * @prop {Number} left - Left edge of the item. Set by layout system and cannot be used in update
       * @prop {Number} top - Top edge of the item. Set by layout system and cannot be used in update
       * @prop {Number} right - Right edge of the item. Set by layout system and cannot be used in update
       * @prop {Number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update
       */
// The layout service is very self explanatory.  It's responsible for the layout within a chart.
// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need
// It is this service's responsibility of carrying out that layout.
var q=t(46);e.exports={defaults:{},
/**
         * Register a box to a chart.
         * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.
         * @param {Chart} chart - the chart to use
         * @param {ILayoutItem} item - the item to add to be layed out
         */
addBox:function t(e,n){e.boxes||(e.boxes=[]),// initialize item with default values
n.fullWidth=n.fullWidth||!1,n.position=n.position||"top",n.weight=n.weight||0,e.boxes.push(n)},
/**
         * Remove a layoutItem from a chart
         * @param {Chart} chart - the chart to remove the box from
         * @param {Object} layoutItem - the item to remove from the layout
         */
removeBox:function t(e,n){var i=e.boxes?e.boxes.indexOf(n):-1;-1!==i&&e.boxes.splice(i,1)},
/**
         * Sets (or updates) options on the given `item`.
         * @param {Chart} chart - the chart in which the item lives (or will be added to)
         * @param {Object} item - the item to configure with the given options
         * @param {Object} options - the new item options.
         */
configure:function t(e,n,i){for(var a=["fullWidth","position","weight"],o=a.length,r=0,l;r<o;++r)l=a[r],i.hasOwnProperty(l)&&(n[l]=i[l])},
/**
         * Fits boxes of the given chart into the given size by having each box measure itself
         * then running a fitting algorithm
         * @param {Chart} chart - the chart
         * @param {Number} width - the width to fit into
         * @param {Number} height - the height to fit into
         */
update:function t(e,n,i){function a(t){var e,n=t.isHorizontal();n?(e=t.update(t.fullWidth?x:S,C),_-=e.height):(e=t.update(M,_),S-=e.width),D.push({horizontal:n,minSize:e,box:t})}// Function to fit a box
function o(e){var t=q.findNextWhere(D,function(t){return t.box===e});if(t)if(e.isHorizontal()){var n={left:Math.max(F,P),right:Math.max(O,I),top:0,bottom:0};// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends
// on the margin. Sometimes they need to increase in size slightly
e.update(e.fullWidth?x:S,y/2,n)}else e.update(t.minSize.width,_)}// Update, and calculate the left and right margins for the horizontal boxes
function r(e){var t=q.findNextWhere(D,function(t){return t.box===e}),n={left:0,right:0,top:R,bottom:L};t&&e.update(t.minSize.width,_,n)}// Let the left layout know the final margin
function l(t){t.isHorizontal()?(t.left=t.fullWidth?d:F,t.right=t.fullWidth?n-c:F+S,t.top=E,t.bottom=E+t.height,// Move to next point
E=t.bottom):(t.left=V,t.right=V+t.width,t.top=R,t.bottom=R+_,// Move to next point
V=t.right)}if(e){var s=e.options.layout||{},u=q.options.toPadding(s.padding),d=u.left,c=u.right,h=u.top,f=u.bottom,g=H(e.boxes,"left"),p=H(e.boxes,"right"),m=H(e.boxes,"top"),v=H(e.boxes,"bottom"),b=H(e.boxes,"chartArea");// Sort boxes by weight. A higher weight is further away from the chart area
j(g,!0),j(p,!1),j(m,!0),j(v,!1);// Essentially we now have any number of boxes on each of the 4 sides.
// Our canvas looks like the following.
// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and
// B1 is the bottom axis
// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays
// These locations are single-box locations only, when trying to register a chartArea location that is already taken,
// an error will be thrown.
//
// |----------------------------------------------------|
// |                  T1 (Full Width)                   |
// |----------------------------------------------------|
// |    |    |                 T2                  |    |
// |    |----|-------------------------------------|----|
// |    |    | C1 |                           | C2 |    |
// |    |    |----|                           |----|    |
// |    |    |                                     |    |
// | L1 | L2 |           ChartArea (C0)            | R1 |
// |    |    |                                     |    |
// |    |    |----|                           |----|    |
// |    |    | C3 |                           | C4 |    |
// |    |----|-------------------------------------|----|
// |    |    |                 B1                  |    |
// |----------------------------------------------------|
// |                  B2 (Full Width)                   |
// |----------------------------------------------------|
//
// What we do to find the best sizing, we do the following
// 1. Determine the minimum size of the chart area.
// 2. Split the remaining width equally between each vertical axis
// 3. Split the remaining height equally between each horizontal axis
// 4. Give each layout the maximum size it can be. The layout will return it's minimum size
// 5. Adjust the sizes of each axis based on it's minimum reported size.
// 6. Refit each axis
// 7. Position each axis in the final location
// 8. Tell the chart the final location of the chart area
// 9. Tell any axes that overlay the chart area the positions of the chart area
// Step 1
var x=n-d-c,y=i-h-f,k,w=y/2,M=(n-x/2)/(g.length+p.length),C=(i-w)/(m.length+v.length),S=x,_=y,D=[];q.each(g.concat(p,m,v),a);// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)
var P=0,I=0,A=0,T=0;q.each(m.concat(v),function(t){if(t.getPadding){var e=t.getPadding();P=Math.max(P,e.left),I=Math.max(I,e.right)}}),q.each(g.concat(p),function(t){if(t.getPadding){var e=t.getPadding();A=Math.max(A,e.top),T=Math.max(T,e.bottom)}});// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could
// be if the axes are drawn at their minimum sizes.
// Steps 5 & 6
var F=d,O=c,R=h,L=f;q.each(g.concat(p),o),q.each(g,function(t){F+=t.width}),q.each(p,function(t){O+=t.width}),// Set the Left and Right margins for the horizontal boxes
q.each(m.concat(v),o),// Figure out how much margin is on the top and bottom of the vertical boxes
q.each(m,function(t){R+=t.height}),q.each(v,function(t){L+=t.height}),q.each(g.concat(p),r),// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)
F=d,O=c,R=h,L=f,q.each(g,function(t){F+=t.width}),q.each(p,function(t){O+=t.width}),q.each(m,function(t){R+=t.height}),q.each(v,function(t){L+=t.height});// We may be adding some padding to account for rotated x axis labels
var z=Math.max(P-F,0);F+=z,O+=Math.max(I-O,0);var N=Math.max(A-R,0);R+=N,L+=Math.max(T-L,0);// Figure out if our chart area changed. This would occur if the dataset layout label rotation
// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do
// without calling `fit` again
var B=i-R-L,W=n-F-O;W===S&&B===_||(q.each(g,function(t){t.height=B}),q.each(p,function(t){t.height=B}),q.each(m,function(t){t.fullWidth||(t.width=W)}),q.each(v,function(t){t.fullWidth||(t.width=W)}),_=B,S=W);// Step 7 - Position the boxes
var V=d+z,E=h+N;q.each(g.concat(m),l),// Account for chart width and height
V+=S,E+=_,q.each(p,l),q.each(v,l),// Step 8
e.chartArea={left:F,top:R,right:F+S,bottom:R+_},// Step 9
q.each(b,function(t){t.left=e.chartArea.left,t.top=e.chartArea.top,t.right=e.chartArea.right,t.bottom=e.chartArea.bottom,t.update(S,_)})}}}},{46:46}],32:[function(t,e,n){var l=t(26),s=t(46);l._set("global",{plugins:{}}),
/**
       * The plugin service singleton
       * @namespace Chart.plugins
       * @since 2.1.0
       */
e.exports={
/**
         * Globally registered plugins.
         * @private
         */
_plugins:[],
/**
         * This identifier is used to invalidate the descriptors cache attached to each chart
         * when a global plugin is registered or unregistered. In this case, the cache ID is
         * incremented and descriptors are regenerated during following API calls.
         * @private
         */
_cacheId:0,
/**
         * Registers the given plugin(s) if not already registered.
         * @param {Array|Object} plugins plugin instance(s).
         */
register:function t(e){var n=this._plugins;[].concat(e).forEach(function(t){-1===n.indexOf(t)&&n.push(t)}),this._cacheId++},
/**
         * Unregisters the given plugin(s) only if registered.
         * @param {Array|Object} plugins plugin instance(s).
         */
unregister:function t(e){var n=this._plugins;[].concat(e).forEach(function(t){var e=n.indexOf(t);-1!==e&&n.splice(e,1)}),this._cacheId++},
/**
         * Remove all registered plugins.
         * @since 2.1.5
         */
clear:function t(){this._plugins=[],this._cacheId++},
/**
         * Returns the number of registered plugins?
         * @returns {Number}
         * @since 2.1.5
         */
count:function t(){return this._plugins.length},
/**
         * Returns all registered plugin instances.
         * @returns {Array} array of plugin objects.
         * @since 2.1.5
         */
getAll:function t(){return this._plugins},
/**
         * Calls enabled plugins for `chart` on the specified hook and with the given args.
         * This method immediately returns as soon as a plugin explicitly returns false. The
         * returned value can be used, for instance, to interrupt the current action.
         * @param {Object} chart - The chart instance for which plugins should be called.
         * @param {String} hook - The name of the plugin method to call (e.g. 'beforeUpdate').
         * @param {Array} [args] - Extra arguments to apply to the hook call.
         * @returns {Boolean} false if any of the plugins return false, else returns true.
         */
notify:function t(e,n,i){var a=this.descriptors(e),o=a.length,r,l,s,u,d;for(r=0;r<o;++r)if("function"==typeof(d=(s=(l=a[r]).plugin)[n])&&((u=[e].concat(i||[])).push(l.options),!1===d.apply(s,u)))return!1;return!0},
/**
         * Returns descriptors of enabled plugins for the given chart.
         * @returns {Array} [{ plugin, options }]
         * @private
         */
descriptors:function a(t){var e=t.$plugins||(t.$plugins={});if(e.id===this._cacheId)return e.descriptors;var o=[],a=[],n=t&&t.config||{},r=n.options&&n.options.plugins||{};return this._plugins.concat(n.plugins||[]).forEach(function(t){var e;if(-1===o.indexOf(t)){var n=t.id,i=r[n];!1!==i&&(!0===i&&(i=s.clone(l.global.plugins[n])),o.push(t),a.push({plugin:t,options:i||{}}))}}),e.descriptors=a,e.id=this._cacheId,a},
/**
         * Invalidates cache for the given chart: descriptors hold a reference on plugin option,
         * but in some cases, this reference can be changed by the user when updating options.
         * https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167
         * @private
         */
_invalidate:function t(e){delete e.$plugins}}},{26:26,46:46}],33:[function(t,e,n){function S(t){var e=[],n,i;for(n=0,i=t.length;n<i;++n)e.push(t[n].label);return e}function H(t,e,n){var i=t.getPixelForTick(e);return n&&(i-=0===e?(t.getPixelForTick(1)-i)/2:(i-t.getPixelForTick(e-1))/2),i}function _(t,e,n){return Y.isArray(e)?Y.longestText(t,n,e):t.measureText(e).width}function j(t){var e=Y.valueOrDefault,n=k.global,i=e(t.fontSize,n.defaultFontSize),a=e(t.fontStyle,n.defaultFontStyle),o=e(t.fontFamily,n.defaultFontFamily);return{size:i,style:a,family:o,font:Y.fontString(i,a,o)}}function q(t){return Y.options.toLineHeight(Y.valueOrDefault(t.lineHeight,1.2),Y.valueOrDefault(t.fontSize,k.global.defaultFontSize))}var k=t(26),i=t(27),Y=t(46),a=t(35);k._set("scale",{display:!0,position:"left",offset:!1,
// grid line settings
gridLines:{display:!0,color:"rgba(0, 0, 0, 0.1)",lineWidth:1,drawBorder:!0,drawOnChartArea:!0,drawTicks:!0,tickMarkLength:10,zeroLineWidth:1,zeroLineColor:"rgba(0,0,0,0.25)",zeroLineBorderDash:[],zeroLineBorderDashOffset:0,offsetGridLines:!1,borderDash:[],borderDashOffset:0},
// scale label
scaleLabel:{
// display property
display:!1,
// actual label
labelString:"",
// line height
lineHeight:1.2,
// top/bottom padding
padding:{top:4,bottom:4}},
// label settings
ticks:{beginAtZero:!1,minRotation:0,maxRotation:50,mirror:!1,padding:0,reverse:!1,display:!0,autoSkip:!0,autoSkipPadding:0,labelOffset:0,
// We pass through arrays to be rendered as multiline labels, we convert Others to strings here.
callback:a.formatters.values,minor:{},major:{}}}),e.exports=i.extend({
/**
         * Get the padding needed for the scale
         * @method getPadding
         * @private
         * @returns {Padding} the necessary padding
         */
getPadding:function t(){var e=this;return{left:e.paddingLeft||0,top:e.paddingTop||0,right:e.paddingRight||0,bottom:e.paddingBottom||0}},
/**
         * Returns the scale tick objects ({label, major})
         * @since 2.7
         */
getTicks:function t(){return this._ticks},
// These methods are ordered by lifecyle. Utilities then follow.
// Any function defined here is inherited by all scale types.
// Any function can be extended by the scale type
mergeTicksOptions:function t(){var e=this.options.ticks;for(var n in!1===e.minor&&(e.minor={display:!1}),!1===e.major&&(e.major={display:!1}),e)"major"!==n&&"minor"!==n&&(void 0===e.minor[n]&&(e.minor[n]=e[n]),void 0===e.major[n]&&(e.major[n]=e[n]))},beforeUpdate:function t(){Y.callback(this.options.beforeUpdate,[this])},update:function t(e,n,i){var a=this,o,r,l,s,u,d;// BACKWARD COMPATIBILITY
// IMPORTANT: from this point, we consider that `this.ticks` will NEVER change!
// BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)
for(// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
a.beforeUpdate(),// Absorb the master measurements
a.maxWidth=e,a.maxHeight=n,a.margins=Y.extend({left:0,right:0,top:0,bottom:0},i),a.longestTextCache=a.longestTextCache||{},// Dimensions
a.beforeSetDimensions(),a.setDimensions(),a.afterSetDimensions(),// Data min/max
a.beforeDataLimits(),a.determineDataLimits(),a.afterDataLimits(),// Ticks - `this.ticks` is now DEPRECATED!
// Internal ticks are now stored as objects in the PRIVATE `this._ticks` member
// and must not be accessed directly from outside this class. `this.ticks` being
// around for long time and not marked as private, we can't change its structure
// without unexpected breaking changes. If you need to access the scale ticks,
// use scale.getTicks() instead.
a.beforeBuildTicks(),// New implementations should return an array of objects but for BACKWARD COMPAT,
// we still support no return (`this.ticks` internally set by calling this method).
u=a.buildTicks()||[],a.afterBuildTicks(),a.beforeTickToLabelConversion(),// New implementations should return the formatted tick labels but for BACKWARD
// COMPAT, we still support no return (`this.ticks` internally changed by calling
// this method and supposed to contain only string values).
l=a.convertTicksToLabels(u)||a.ticks,a.afterTickToLabelConversion(),o=0,r=(a.ticks=l).length;o<r;++o)s=l[o],(d=u[o])?d.label=s:u.push(d={label:s,major:!1});return a._ticks=u,// Tick Rotation
a.beforeCalculateTickRotation(),a.calculateTickRotation(),a.afterCalculateTickRotation(),// Fit
a.beforeFit(),a.fit(),a.afterFit(),//
a.afterUpdate(),a.minSize},afterUpdate:function t(){Y.callback(this.options.afterUpdate,[this])},
//
beforeSetDimensions:function t(){Y.callback(this.options.beforeSetDimensions,[this])},setDimensions:function t(){var e=this;// Set the unconstrained dimension before label rotation
e.isHorizontal()?(
// Reset position before calculating rotation
e.width=e.maxWidth,e.left=0,e.right=e.width):(e.height=e.maxHeight,// Reset position before calculating rotation
e.top=0,e.bottom=e.height),// Reset padding
e.paddingLeft=0,e.paddingTop=0,e.paddingRight=0,e.paddingBottom=0},afterSetDimensions:function t(){Y.callback(this.options.afterSetDimensions,[this])},
// Data limits
beforeDataLimits:function t(){Y.callback(this.options.beforeDataLimits,[this])},determineDataLimits:Y.noop,afterDataLimits:function t(){Y.callback(this.options.afterDataLimits,[this])},
//
beforeBuildTicks:function t(){Y.callback(this.options.beforeBuildTicks,[this])},buildTicks:Y.noop,afterBuildTicks:function t(){Y.callback(this.options.afterBuildTicks,[this])},beforeTickToLabelConversion:function t(){Y.callback(this.options.beforeTickToLabelConversion,[this])},convertTicksToLabels:function t(){var e=this,n=e.options.ticks;// Convert ticks to strings
e.ticks=e.ticks.map(n.userCallback||n.callback,this)},afterTickToLabelConversion:function t(){Y.callback(this.options.afterTickToLabelConversion,[this])},
//
beforeCalculateTickRotation:function t(){Y.callback(this.options.beforeCalculateTickRotation,[this])},calculateTickRotation:function t(){var e=this,n=e.ctx,i=e.options.ticks,a=S(e._ticks),o=j(i);n.font=o.font;var r=i.minRotation||0;if(a.length&&e.options.display&&e.isHorizontal())// Max label rotation can be set or default to 90 - also act as a loop counter
for(var l=Y.longestText(n,o.font,a,e.longestTextCache),s=l,u,d,c=e.getPixelForTick(1)-e.getPixelForTick(0)-6;c<s&&r<i.maxRotation;){var h=Y.toRadians(r);if(u=Math.cos(h),(d=Math.sin(h))*l>e.maxHeight){
// go back one step
r--;break}r++,s=u*l}e.labelRotation=r},afterCalculateTickRotation:function t(){Y.callback(this.options.afterCalculateTickRotation,[this])},
//
beforeFit:function t(){Y.callback(this.options.beforeFit,[this])},fit:function t(){var e=this,n=e.minSize={width:0,height:0},i=S(e._ticks),a=e.options,o=a.ticks,r=a.scaleLabel,l=a.gridLines,s=a.display,u=e.isHorizontal(),d=j(o),c=a.gridLines.tickMarkLength;// Reset
// Are we showing a title for the scale?
if(// Width
// subtract the margins to line up with the chartArea if we are a full width scale
n.width=u?e.isFullWidth()?e.maxWidth-e.margins.left-e.margins.right:e.maxWidth:s&&l.drawTicks?c:0,// height
n.height=u?s&&l.drawTicks?c:0:e.maxHeight,r.display&&s){var h,f,g=q(r)+Y.options.toPadding(r.padding).height;u?n.height+=g:n.width+=g}// Don't bother fitting the ticks if we are not showing them
if(o.display&&s){var p=Y.longestText(e.ctx,d.font,i,e.longestTextCache),m=Y.numberOfLabelLines(i),v=.5*d.size,b=e.options.ticks.padding;if(u){
// A horizontal axis is more constrained by the height.
e.longestLabelWidth=p;var x=Y.toRadians(e.labelRotation),y=Math.cos(x),k,w=Math.sin(x)*p+d.size*m+v*(m-1)+v;// padding
n.height=Math.min(e.maxHeight,n.height+w+b),e.ctx.font=d.font;var M=_(e.ctx,i[0],d.font),C=_(e.ctx,i[i.length-1],d.font);// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned
// which means that the right padding is dominated by the font height
0!==e.labelRotation?(e.paddingLeft="bottom"===a.position?y*M+3:y*v+3,// add 3 px to move away from canvas edges
e.paddingRight="bottom"===a.position?y*v+3:y*C+3):(e.paddingLeft=M/2+3,// add 3 px to move away from canvas edges
e.paddingRight=C/2+3)}else
// A vertical axis is more constrained by the width. Labels are the
// dominant factor here, so get that length first and account for padding
o.mirror?p=0:
// use lineSpace for consistency with horizontal axis
// tickPadding is not implemented for horizontal
p+=b+v,n.width=Math.min(e.maxWidth,n.width+p),e.paddingTop=d.size/2,e.paddingBottom=d.size/2}e.handleMargins(),e.width=n.width,e.height=n.height},
/**
         * Handle margins and padding interactions
         * @private
         */
handleMargins:function t(){var e=this;e.margins&&(e.paddingLeft=Math.max(e.paddingLeft-e.margins.left,0),e.paddingTop=Math.max(e.paddingTop-e.margins.top,0),e.paddingRight=Math.max(e.paddingRight-e.margins.right,0),e.paddingBottom=Math.max(e.paddingBottom-e.margins.bottom,0))},afterFit:function t(){Y.callback(this.options.afterFit,[this])},
// Shared Methods
isHorizontal:function t(){return"top"===this.options.position||"bottom"===this.options.position},isFullWidth:function t(){return this.options.fullWidth},
// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not
getRightValue:function t(e){
// Null and undefined values first
if(Y.isNullOrUndef(e))return NaN;// isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values
if("number"==typeof e&&!isFinite(e))return NaN;// If it is in fact an object, dive in one more level
if(e)if(this.isHorizontal()){if(void 0!==e.x)return this.getRightValue(e.x)}else if(void 0!==e.y)return this.getRightValue(e.y);// Value is good, return it
return e},
/**
         * Used to get the value to display in the tooltip for the data at the given index
         * @param index
         * @param datasetIndex
         */
getLabelForIndex:Y.noop,
/**
         * Returns the location of the given data point. Value can either be an index or a numerical value
         * The coordinate (0, 0) is at the upper-left corner of the canvas
         * @param value
         * @param index
         * @param datasetIndex
         */
getPixelForValue:Y.noop,
/**
         * Used to get the data value from a given pixel. This is the inverse of getPixelForValue
         * The coordinate (0, 0) is at the upper-left corner of the canvas
         * @param pixel
         */
getValueForPixel:Y.noop,
/**
         * Returns the location of the tick at the given index
         * The coordinate (0, 0) is at the upper-left corner of the canvas
         */
getPixelForTick:function t(e){var n=this,i=n.options.offset;if(n.isHorizontal()){var a,o=(n.width-(n.paddingLeft+n.paddingRight))/Math.max(n._ticks.length-(i?0:1),1),r=o*e+n.paddingLeft;i&&(r+=o/2);var l=n.left+Math.round(r);return l+=n.isFullWidth()?n.margins.left:0}var s=n.height-(n.paddingTop+n.paddingBottom);return n.top+e*(s/(n._ticks.length-1))},
/**
         * Utility for getting the pixel location of a percentage of scale
         * The coordinate (0, 0) is at the upper-left corner of the canvas
         */
getPixelForDecimal:function t(e){var n=this;if(n.isHorizontal()){var i,a=(n.width-(n.paddingLeft+n.paddingRight))*e+n.paddingLeft,o=n.left+Math.round(a);return o+=n.isFullWidth()?n.margins.left:0}return n.top+e*n.height},
/**
         * Returns the pixel for the minimum chart value
         * The coordinate (0, 0) is at the upper-left corner of the canvas
         */
getBasePixel:function t(){return this.getPixelForValue(this.getBaseValue())},getBaseValue:function t(){var e=this,n=e.min,i=e.max;return e.beginAtZero?0:n<0&&i<0?i:0<n&&0<i?n:0},
/**
         * Returns a subset of ticks to be plotted to avoid overlapping labels.
         * @private
         */
_autoSkip:function t(e){var n,i=this,a=i.isHorizontal(),o=i.options.ticks.minor,r=e.length,l=Y.toRadians(i.labelRotation),s=Math.cos(l),u=i.longestLabelWidth*s,d=[],c,h,f,g;for(o.maxTicksLimit&&(g=o.maxTicksLimit),a&&(n=!1,(u+o.autoSkipPadding)*r>i.width-(i.paddingLeft+i.paddingRight)&&(n=1+Math.floor((u+o.autoSkipPadding)*r/(i.width-(i.paddingLeft+i.paddingRight)))),// if they defined a max number of optionTicks,
// increase skipRatio until that number is met
g&&g<r&&(n=Math.max(n,Math.floor(r/g)))),c=0;c<r;c++)h=e[c],(// Since we always show the last tick,we need may need to hide the last shown one before
f=1<n&&0<c%n||c%n==0&&r<=c+n)&&c!==r-1&&
// leave tick in place but make sure it's not displayed (#4635)
delete h.label,d.push(h);return d},
// Actually draw the scale on the canvas
// @param {rectangle} chartArea : the area of the chart to draw full grid lines on
draw:function t(S){var _=this,D=_.options;if(D.display){var r=_.ctx,P=k.global,I=D.ticks.minor,e=D.ticks.major||I,A=D.gridLines,n=D.scaleLabel,T=0!==_.labelRotation,F=_.isHorizontal(),O=I.autoSkip?_._autoSkip(_.getTicks()):_.getTicks(),l=Y.valueOrDefault(I.fontColor,P.defaultFontColor),s=j(I),u=Y.valueOrDefault(e.fontColor,P.defaultFontColor),d=j(e),R=A.drawTicks?A.tickMarkLength:0,i=Y.valueOrDefault(n.fontColor,P.defaultFontColor),a=j(n),o=Y.options.toPadding(n.padding),L=Y.toRadians(_.labelRotation),z=[],N=_.options.gridLines.lineWidth,B="right"===D.position?_.left:_.right-N-R,W="right"===D.position?_.left+R:_.right,V="bottom"===D.position?_.top+N:_.bottom-R-N,E="bottom"===D.position?_.top+N+R:_.bottom+N;if(Y.each(O,function(t,e){
// autoskipper skipped this tick (#4635)
if(!Y.isNullOrUndef(t.label)){var n=t.label,i,a,o,r,l,s,u,d,c,h,f,g,p,m;r=e===_.zeroLineIndex&&D.offset===A.offsetGridLines?(
// Draw the first index specially
i=A.zeroLineWidth,a=A.zeroLineColor,o=A.zeroLineBorderDash,A.zeroLineBorderDashOffset):(i=Y.valueAtIndexOrDefault(A.lineWidth,e),a=Y.valueAtIndexOrDefault(A.color,e),o=Y.valueOrDefault(A.borderDash,P.borderDash),Y.valueOrDefault(A.borderDashOffset,P.borderDashOffset));// Common properties
var v="middle",b="middle",x=I.padding;if(F){var y=R+x;m="bottom"===D.position?(
// bottom
b=T?"middle":"top",v=T?"right":"center",_.top+y):(
// top
b=T?"middle":"bottom",v=T?"left":"center",_.bottom-y);var k=H(_,e,A.offsetGridLines&&1<O.length);k<_.left&&(a="rgba(0,0,0,0)"),k+=Y.aliasPixel(i),p=_.getPixelForTick(e)+I.labelOffset,// x values for optionTicks (need to consider offsetLabel option)
l=u=c=f=k,s=V,d=E,h=S.top,g=S.bottom+N}else{var w="left"===D.position,M;M=I.mirror?(v=w?"left":"right",x):(v=w?"right":"left",R+x),p=w?_.right-M:_.left+M;var C=H(_,e,A.offsetGridLines&&1<O.length);C<_.top&&(a="rgba(0,0,0,0)"),C+=Y.aliasPixel(i),m=_.getPixelForTick(e)+I.labelOffset,l=B,u=W,c=S.left,f=S.right+N,s=d=h=g=C}z.push({tx1:l,ty1:s,tx2:u,ty2:d,x1:c,y1:h,x2:f,y2:g,labelX:p,labelY:m,glWidth:i,glColor:a,glBorderDash:o,glBorderDashOffset:r,rotation:-1*L,label:n,major:t.major,textBaseline:b,textAlign:v})}}),// Draw all of the tick labels, tick marks, and grid lines at the correct places
Y.each(z,function(t){if(A.display&&(r.save(),r.lineWidth=t.glWidth,r.strokeStyle=t.glColor,r.setLineDash&&(r.setLineDash(t.glBorderDash),r.lineDashOffset=t.glBorderDashOffset),r.beginPath(),A.drawTicks&&(r.moveTo(t.tx1,t.ty1),r.lineTo(t.tx2,t.ty2)),A.drawOnChartArea&&(r.moveTo(t.x1,t.y1),r.lineTo(t.x2,t.y2)),r.stroke(),r.restore()),I.display){
// Make sure we draw text in the correct color and font
r.save(),r.translate(t.labelX,t.labelY),r.rotate(t.rotation),r.font=t.major?d.font:s.font,r.fillStyle=t.major?u:l,r.textBaseline=t.textBaseline,r.textAlign=t.textAlign;var e=t.label;if(Y.isArray(e))for(var n=e.length,i=1.5*s.size,a=_.isHorizontal()?0:-i*(n-1)/2,o=0;o<n;++o)
// We just make sure the multiline element is a string here..
r.fillText(""+e[o],0,a),// apply same lineSpacing as calculated @ L#320
a+=i;else r.fillText(e,0,0);r.restore()}}),n.display){
// Draw the scale label
var c,h,f=0,g=q(n)/2;if(F)c=_.left+(_.right-_.left)/2,// midpoint of the width
h="bottom"===D.position?_.bottom-g-o.bottom:_.top+g+o.top;else{var p="left"===D.position;c=p?_.left+g+o.top:_.right-g-o.top,h=_.top+(_.bottom-_.top)/2,f=p?-.5*Math.PI:.5*Math.PI}r.save(),r.translate(c,h),r.rotate(f),r.textAlign="center",r.textBaseline="middle",r.fillStyle=i,// render in correct colour
r.font=a.font,r.fillText(n.labelString,0,0),r.restore()}if(A.drawBorder){
// Draw the line at the edge of the axis
r.lineWidth=Y.valueAtIndexOrDefault(A.lineWidth,0),r.strokeStyle=Y.valueAtIndexOrDefault(A.color,0);var m=_.left,v=_.right+N,b=_.top,x=_.bottom+N,y=Y.aliasPixel(r.lineWidth);F?(b=x="top"===D.position?_.bottom:_.top,b+=y,x+=y):(m=v="left"===D.position?_.right:_.left,m+=y,v+=y),r.beginPath(),r.moveTo(m,b),r.lineTo(v,x),r.stroke()}}}})},{26:26,27:27,35:35,46:46}],34:[function(t,e,n){var i=t(26),a=t(46),o=t(31);e.exports={
// Scale registration object. Extensions can register new scale types (such as log or DB scales) and then
// use the new chart options to grab the correct scale
constructors:{},
// Use a registration function so that we can move to an ES6 map when we no longer need to support
// old browsers
// Scale config defaults
defaults:{},registerScaleType:function t(e,n,i){this.constructors[e]=n,this.defaults[e]=a.clone(i)},getScaleConstructor:function t(e){return this.constructors.hasOwnProperty(e)?this.constructors[e]:void 0},getScaleDefaults:function t(e){
// Return the scale defaults merged with the global settings so that we always use the latest ones
return this.defaults.hasOwnProperty(e)?a.merge({},[i.scale,this.defaults[e]]):{}},updateScaleDefaults:function t(e,n){var i=this;i.defaults.hasOwnProperty(e)&&(i.defaults[e]=a.extend(i.defaults[e],n))},addScalesToLayout:function t(e){
// Adds each scale to the chart.boxes array to be sized accordingly
a.each(e.scales,function(t){
// Set ILayoutItem parameters for backwards compatibility
t.fullWidth=t.options.fullWidth,t.position=t.options.position,t.weight=t.options.weight,o.addBox(e,t)})}}},{26:26,31:31,46:46}],35:[function(t,e,n){var d=t(46);
/**
       * Namespace to hold static tick generation functions
       * @namespace Chart.Ticks
       */e.exports={
/**
         * Namespace to hold formatters for different types of ticks
         * @namespace Chart.Ticks.formatters
         */
formatters:{
/**
           * Formatter for value labels
           * @method Chart.Ticks.formatters.values
           * @param value the value to display
           * @return {String|Array} the label to display
           */
values:function t(e){return d.isArray(e)?e:""+e},
/**
           * Formatter for linear numeric ticks
           * @method Chart.Ticks.formatters.linear
           * @param tickValue {Number} the value to be formatted
           * @param index {Number} the position of the tickValue parameter in the ticks array
           * @param ticks {Array<Number>} the list of ticks being converted
           * @return {String} string representation of the tickValue parameter
           */
linear:function t(e,n,i){
// If we have lots of ticks, don't use the ones
var a=3<i.length?i[2]-i[1]:i[1]-i[0];// If we have a number like 2.5 as the delta, figure out how many decimal places we need
1<Math.abs(a)&&e!==Math.floor(e)&&(
// not an integer
a=e-Math.floor(e));var o=d.log10(Math.abs(a)),r="",l;if(0!==e)if(Math.max(Math.abs(i[0]),Math.abs(i[i.length-1]))<1e-4){
// all ticks are small numbers; use scientific notation
var s=d.log10(Math.abs(e));r=e.toExponential(Math.floor(s)-Math.floor(o))}else{var u=-1*Math.floor(o);u=Math.max(Math.min(u,20),0),// toFixed has a max of 20 decimal places
r=e.toFixed(u)}else r="0";// never show decimal places for 0
return r},logarithmic:function t(e,n,i){var a=e/Math.pow(10,Math.floor(d.log10(e)));return 0===e?"0":1===a||2===a||5===a||0===n||n===i.length-1?e.toExponential():""}}}},{46:46}],36:[function(t,e,n){
/**
       * Helper method to merge the opacity into a color
       */
function f(t,e){var n=w.color(t);return n.alpha(e*n.alpha()).rgbaString()}// Helper to push or concat based on if the 2nd parameter is an array or not
function s(t,e){return e&&(w.isArray(e)?
// base = base.concat(toPush);
Array.prototype.push.apply(t,e):t.push(e)),t}
/**
       * Returns array of strings split by newline
       * @param {String} value - The value to split by newline.
       * @returns {Array} value if newline present - Returned from String split() method
       * @function
       */function u(t){return("string"==typeof t||t instanceof String)&&-1<t.indexOf("\n")?t.split("\n"):t}// Private helper to create a tooltip item model
// @param element : the chart element (point, arc, bar) to create the tooltip item for
// @return : new tooltip item
function v(t){var e=t._xScale,n=t._yScale||t._scale,i=t._index,a=t._datasetIndex;return{xLabel:e?e.getLabelForIndex(i,a):"",yLabel:n?n.getLabelForIndex(i,a):"",index:i,datasetIndex:a,x:t._model.x,y:t._model.y}}
/**
       * Helper to get the reset model for the tooltip
       * @param tooltipOpts {Object} the tooltip options
       */function b(t){var e=a.global,n=w.valueOrDefault;return{
// Positioning
xPadding:t.xPadding,yPadding:t.yPadding,xAlign:t.xAlign,yAlign:t.yAlign,
// Body
bodyFontColor:t.bodyFontColor,_bodyFontFamily:n(t.bodyFontFamily,e.defaultFontFamily),_bodyFontStyle:n(t.bodyFontStyle,e.defaultFontStyle),_bodyAlign:t.bodyAlign,bodyFontSize:n(t.bodyFontSize,e.defaultFontSize),bodySpacing:t.bodySpacing,
// Title
titleFontColor:t.titleFontColor,_titleFontFamily:n(t.titleFontFamily,e.defaultFontFamily),_titleFontStyle:n(t.titleFontStyle,e.defaultFontStyle),titleFontSize:n(t.titleFontSize,e.defaultFontSize),_titleAlign:t.titleAlign,titleSpacing:t.titleSpacing,titleMarginBottom:t.titleMarginBottom,
// Footer
footerFontColor:t.footerFontColor,_footerFontFamily:n(t.footerFontFamily,e.defaultFontFamily),_footerFontStyle:n(t.footerFontStyle,e.defaultFontStyle),footerFontSize:n(t.footerFontSize,e.defaultFontSize),_footerAlign:t.footerAlign,footerSpacing:t.footerSpacing,footerMarginTop:t.footerMarginTop,
// Appearance
caretSize:t.caretSize,cornerRadius:t.cornerRadius,backgroundColor:t.backgroundColor,opacity:0,legendColorBackground:t.multiKeyBackground,displayColors:t.displayColors,borderColor:t.borderColor,borderWidth:t.borderWidth}}
/**
       * Get the size of the tooltip
       */function x(t,e){var n=t._chart.ctx,i=2*e.yPadding,a=0,o=e.body,r=o.reduce(function(t,e){return t+e.before.length+e.lines.length+e.after.length},0);r+=e.beforeBody.length+e.afterBody.length;var l=e.title.length,s=e.footer.length,u=e.titleFontSize,d=e.bodyFontSize,c=e.footerFontSize;i+=l*u,// Title Lines
i+=l?(l-1)*e.titleSpacing:0,// Title Line Spacing
i+=l?e.titleMarginBottom:0,// Title's bottom Margin
i+=r*d,// Body Lines
i+=r?(r-1)*e.bodySpacing:0,// Body Line Spacing
i+=s?e.footerMarginTop:0,// Footer Margin
i+=s*c,// Footer Lines
i+=s?(s-1)*e.footerSpacing:0;// Footer Line Spacing
// Title width
var h=0,f=function t(e){a=Math.max(a,n.measureText(e).width+h)};return n.font=w.fontString(u,e._titleFontStyle,e._titleFontFamily),w.each(e.title,f),// Body width
n.font=w.fontString(d,e._bodyFontStyle,e._bodyFontFamily),w.each(e.beforeBody.concat(e.afterBody),f),// Body lines may include some extra width due to the color box
h=e.displayColors?d+2:0,w.each(o,function(t){w.each(t.before,f),w.each(t.lines,f),w.each(t.after,f)}),// Reset back to 0
h=0,// Footer width
n.font=w.fontString(c,e._footerFontStyle,e._footerFontFamily),w.each(e.footer,f),{width:// Add padding
a+=2*e.xPadding,height:i}}
/**
       * Helper to get the alignment of a tooltip given the size
       */function y(t,n){var i=t._model,a=t._chart,e=t._chart.chartArea,o="center",r="center",l,s,u,d,c;i.y<n.height?r="top":i.y>a.height-n.height&&(r="bottom");// function to get the y alignment if the tooltip goes outside of the left or right edges
var h=(e.left+e.right)/2,f=(e.top+e.bottom)/2;s="center"===r?(l=function t(e){return e<=h},function t(e){return h<e}):(l=function t(e){return e<=n.width/2},function t(e){return e>=a.width-n.width/2}),u=function t(e){return e+n.width+i.caretSize+i.caretPadding>a.width},d=function t(e){return e-n.width-i.caretSize-i.caretPadding<0},c=function t(e){return e<=f?"top":"bottom"},l(i.x)?(o="left",// Is tooltip too wide and goes over the right side of the chart.?
u(i.x)&&(o="center",r=c(i.y))):s(i.x)&&(o="right",// Is tooltip too wide and goes outside left edge of canvas?
d(i.x)&&(o="center",r=c(i.y)));var g=t._options;return{xAlign:g.xAlign?g.xAlign:o,yAlign:g.yAlign?g.yAlign:r}}
/**
       * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment
       */function k(t,e,n,i){
// Background Position
var a=t.x,o=t.y,r=t.caretSize,l=t.caretPadding,s=t.cornerRadius,u=n.xAlign,d=n.yAlign,c=r+l,h=s+l;return"right"===u?a-=e.width:"center"===u&&((a-=e.width/2)+e.width>i.width&&(a=i.width-e.width),a<0&&(a=0)),"top"===d?o+=c:o-="bottom"===d?e.height+c:e.height/2,"center"===d?"left"===u?a+=c:"right"===u&&(a-=c):"left"===u?a-=h:"right"===u&&(a+=h),{x:a,y:o}}
/**
       * Helper to build before and after body lines
       */function i(t){return s([],u(t))}var a=t(26),o=t(27),w=t(46);a._set("global",{tooltips:{enabled:!0,custom:null,mode:"nearest",position:"average",intersect:!0,backgroundColor:"rgba(0,0,0,0.8)",titleFontStyle:"bold",titleSpacing:2,titleMarginBottom:6,titleFontColor:"#fff",titleAlign:"left",bodySpacing:2,bodyFontColor:"#fff",bodyAlign:"left",footerFontStyle:"bold",footerSpacing:2,footerMarginTop:6,footerFontColor:"#fff",footerAlign:"left",yPadding:6,xPadding:6,caretPadding:2,caretSize:5,cornerRadius:6,multiKeyBackground:"#fff",displayColors:!0,borderColor:"rgba(0,0,0,0)",borderWidth:0,callbacks:{
// Args are: (tooltipItems, data)
beforeTitle:w.noop,title:function t(e,n){
// Pick first xLabel for now
var t="",i=n.labels,a=i?i.length:0;if(0<e.length){var o=e[0];o.xLabel?t=o.xLabel:0<a&&o.index<a&&(t=i[o.index])}return t},afterTitle:w.noop,
// Args are: (tooltipItems, data)
beforeBody:w.noop,
// Args are: (tooltipItem, data)
beforeLabel:w.noop,label:function t(e,n){var t=n.datasets[e.datasetIndex].label||"";return t&&(t+=": "),t+=e.yLabel,t},labelColor:function t(e,n){var i,a,o=n.getDatasetMeta(e.datasetIndex).data[e.index]._view;return{borderColor:o.borderColor,backgroundColor:o.backgroundColor}},labelTextColor:function t(){return this._options.bodyFontColor},afterLabel:w.noop,
// Args are: (tooltipItems, data)
afterBody:w.noop,
// Args are: (tooltipItems, data)
beforeFooter:w.noop,footer:w.noop,afterFooter:w.noop}}});var M={
/**
         * Average mode places the tooltip at the average position of the elements shown
         * @function Chart.Tooltip.positioners.average
         * @param elements {ChartElement[]} the elements being displayed in the tooltip
         * @returns {Point} tooltip position
         */
average:function t(e){if(!e.length)return!1;var n,i,a=0,o=0,r=0;for(n=0,i=e.length;n<i;++n){var l=e[n];if(l&&l.hasValue()){var s=l.tooltipPosition();a+=s.x,o+=s.y,++r}}return{x:Math.round(a/r),y:Math.round(o/r)}},
/**
         * Gets the tooltip position nearest of the item nearest to the event position
         * @function Chart.Tooltip.positioners.nearest
         * @param elements {Chart.Element[]} the tooltip elements
         * @param eventPosition {Point} the position of the event in canvas coordinates
         * @returns {Point} the tooltip position
         */
nearest:function t(e,n){var i=n.x,a=n.y,o=Number.POSITIVE_INFINITY,r,l,s;for(r=0,l=e.length;r<l;++r){var u=e[r];if(u&&u.hasValue()){var d=u.getCenterPoint(),c=w.distanceBetweenPoints(n,d);c<o&&(o=c,s=u)}}if(s){var h=s.tooltipPosition();i=h.x,a=h.y}return{x:i,y:a}}},n;
/**
       * @namespace Chart.Tooltip.positioners
       */
(e.exports=o.extend({initialize:function t(){this._model=b(this._options),this._lastActive=[]},
// Get the title
// Args are: (tooltipItem, data)
getTitle:function t(){var e=this,n,i=e._options.callbacks,a=i.beforeTitle.apply(e,arguments),o=i.title.apply(e,arguments),r=i.afterTitle.apply(e,arguments),l=[];return l=s(l=s(l=s(l,u(a)),u(o)),u(r))},
// Args are: (tooltipItem, data)
getBeforeBody:function t(){return i(this._options.callbacks.beforeBody.apply(this,arguments))},
// Args are: (tooltipItem, data)
getBody:function t(e,n){var i=this,a=i._options.callbacks,o=[];return w.each(e,function(t){var e={before:[],lines:[],after:[]};s(e.before,u(a.beforeLabel.call(i,t,n))),s(e.lines,a.label.call(i,t,n)),s(e.after,u(a.afterLabel.call(i,t,n))),o.push(e)}),o},
// Args are: (tooltipItem, data)
getAfterBody:function t(){return i(this._options.callbacks.afterBody.apply(this,arguments))},
// Get the footer and beforeFooter and afterFooter lines
// Args are: (tooltipItem, data)
getFooter:function t(){var e=this,n=e._options.callbacks,i=n.beforeFooter.apply(e,arguments),a=n.footer.apply(e,arguments),o=n.afterFooter.apply(e,arguments),r=[];return r=s(r=s(r=s(r,u(i)),u(a)),u(o))},update:function t(e){var n=this,i=n._options,a=n._model,o=n._model=b(i),r=n._active,l=n._data,s={xAlign:a.xAlign,yAlign:a.yAlign},u={x:a.x,y:a.y},d={width:a.width,height:a.height},c={x:a.caretX,y:a.caretY},h,f;if(r.length){o.opacity=1;var g=[],p=[];c=M[i.position].call(n,r,n._eventPosition);var m=[];for(h=0,f=r.length;h<f;++h)m.push(v(r[h]));// If the user provided a filter function, use it to modify the tooltip items
i.filter&&(m=m.filter(function(t){return i.filter(t,l)})),// If the user provided a sorting function, use it to modify the tooltip items
i.itemSort&&(m=m.sort(function(t,e){return i.itemSort(t,e,l)})),// Determine colors for boxes
w.each(m,function(t){g.push(i.callbacks.labelColor.call(n,t,n._chart)),p.push(i.callbacks.labelTextColor.call(n,t,n._chart))}),// Build the Text Lines
o.title=n.getTitle(m,l),o.beforeBody=n.getBeforeBody(m,l),o.body=n.getBody(m,l),o.afterBody=n.getAfterBody(m,l),o.footer=n.getFooter(m,l),// Initial positioning and colors
o.x=Math.round(c.x),o.y=Math.round(c.y),o.caretPadding=i.caretPadding,o.labelColors=g,o.labelTextColors=p,// data points
o.dataPoints=m,// Final Size and Position
u=k(o,// We need to determine alignment of the tooltip
d=x(this,o),s=y(this,d),n._chart)}else o.opacity=0;return o.xAlign=s.xAlign,o.yAlign=s.yAlign,o.x=u.x,o.y=u.y,o.width=d.width,o.height=d.height,// Point where the caret on the tooltip points to
o.caretX=c.x,o.caretY=c.y,n._model=o,e&&i.custom&&i.custom.call(n,o),n},drawCaret:function t(e,n){var i=this._chart.ctx,a=this._view,o=this.getCaretPosition(e,n,a);i.lineTo(o.x1,o.y1),i.lineTo(o.x2,o.y2),i.lineTo(o.x3,o.y3)},getCaretPosition:function t(e,n,i){var a,o,r,l,s,u,d=i.caretSize,c=i.cornerRadius,h=i.xAlign,f=i.yAlign,g=e.x,p=e.y,m=n.width,v=n.height;if("center"===f)s=p+v/2,u="left"===h?(o=(a=g)-d,r=a,l=s+d,s-d):(o=(a=g+m)+d,r=a,l=s-d,s+d);else if(r=(a="left"===h?(o=g+c+d)-d:"right"===h?(o=g+m-c-d)-d:(o=i.caretX)-d,o+d),"top"===f)s=(l=p)-d,u=l;else{s=(l=p+v)+d,u=l;// invert drawing order
var b=r;r=a,a=b}return{x1:a,x2:o,x3:r,y1:l,y2:s,y3:u}},drawTitle:function t(e,n,i,a){var o=n.title;if(o.length){i.textAlign=n._titleAlign,i.textBaseline="top";var r=n.titleFontSize,l=n.titleSpacing,s,u;for(i.fillStyle=f(n.titleFontColor,a),i.font=w.fontString(r,n._titleFontStyle,n._titleFontFamily),s=0,u=o.length;s<u;++s)i.fillText(o[s],e.x,e.y),e.y+=r+l,// Line Height and spacing
s+1===o.length&&(e.y+=n.titleMarginBottom-l)}},drawBody:function t(i,a,o,r){var l=a.bodyFontSize,n=a.bodySpacing,e=a.body;o.textAlign=a._bodyAlign,o.textBaseline="top",o.font=w.fontString(l,a._bodyFontStyle,a._bodyFontFamily);// Before Body
var s=0,u=function t(e){o.fillText(e,i.x+s,i.y),i.y+=l+n};// Before body lines
o.fillStyle=f(a.bodyFontColor,r),w.each(a.beforeBody,u);var d=a.displayColors;s=d?l+2:0,// Draw body lines now
w.each(e,function(t,e){var n=f(a.labelTextColors[e],r);o.fillStyle=n,w.each(t.before,u),w.each(t.lines,function(t){
// Draw Legend-like boxes if needed
d&&(
// Fill a white rect so that colours merge nicely if the opacity is < 1
o.fillStyle=f(a.legendColorBackground,r),o.fillRect(i.x,i.y,l,l),// Border
o.lineWidth=1,o.strokeStyle=f(a.labelColors[e].borderColor,r),o.strokeRect(i.x,i.y,l,l),// Inner square
o.fillStyle=f(a.labelColors[e].backgroundColor,r),o.fillRect(i.x+1,i.y+1,l-2,l-2),o.fillStyle=n),u(t)}),w.each(t.after,u)}),// Reset back to 0 for after body
s=0,// After body lines
w.each(a.afterBody,u),i.y-=n},drawFooter:function t(e,n,i,a){var o=n.footer;o.length&&(e.y+=n.footerMarginTop,i.textAlign=n._footerAlign,i.textBaseline="top",i.fillStyle=f(n.footerFontColor,a),i.font=w.fontString(n.footerFontSize,n._footerFontStyle,n._footerFontFamily),w.each(o,function(t){i.fillText(t,e.x,e.y),e.y+=n.footerFontSize+n.footerSpacing}))},drawBackground:function t(e,n,i,a,o){i.fillStyle=f(n.backgroundColor,o),i.strokeStyle=f(n.borderColor,o),i.lineWidth=n.borderWidth;var r=n.xAlign,l=n.yAlign,s=e.x,u=e.y,d=a.width,c=a.height,h=n.cornerRadius;i.beginPath(),i.moveTo(s+h,u),"top"===l&&this.drawCaret(e,a),i.lineTo(s+d-h,u),i.quadraticCurveTo(s+d,u,s+d,u+h),"center"===l&&"right"===r&&this.drawCaret(e,a),i.lineTo(s+d,u+c-h),i.quadraticCurveTo(s+d,u+c,s+d-h,u+c),"bottom"===l&&this.drawCaret(e,a),i.lineTo(s+h,u+c),i.quadraticCurveTo(s,u+c,s,u+c-h),"center"===l&&"left"===r&&this.drawCaret(e,a),i.lineTo(s,u+h),i.quadraticCurveTo(s,u,s+h,u),i.closePath(),i.fill(),0<n.borderWidth&&i.stroke()},draw:function t(){var e=this._chart.ctx,n=this._view;if(0!==n.opacity){var i={width:n.width,height:n.height},a={x:n.x,y:n.y},o=Math.abs(n.opacity<.001)?0:n.opacity,r=n.title.length||n.beforeBody.length||n.body.length||n.afterBody.length||n.footer.length;this._options.enabled&&r&&(
// Draw Background
this.drawBackground(a,n,e,i,o),// Draw Title, Body, and Footer
a.x+=n.xPadding,a.y+=n.yPadding,// Titles
this.drawTitle(a,n,e,o),// Body
this.drawBody(a,n,e,o),// Footer
this.drawFooter(a,n,e,o))}},
/**
         * Handle an event
         * @private
         * @param {IEvent} event - The event to handle
         * @returns {Boolean} true if the tooltip changed
         */
handleEvent:function t(e){var n=this,i=n._options,a=!1;return n._lastActive=n._lastActive||[],// Find Active Elements for tooltips
"mouseout"===e.type?n._active=[]:n._active=n._chart.getElementsAtEventForMode(e,i.mode,i),// Only handle target event on tooltip change
(// Remember Last Actives
a=!w.arrayEquals(n._active,n._lastActive))&&(n._lastActive=n._active,(i.enabled||i.custom)&&(n._eventPosition={x:e.x,y:e.y},n.update(!0),n.pivot())),a}})).positioners=M},{26:26,27:27,46:46}],37:[function(t,e,n){var i=t(26),a=t(27),c=t(46);i._set("global",{elements:{arc:{backgroundColor:i.global.defaultColor,borderColor:"#fff",borderWidth:2}}}),e.exports=a.extend({inLabelRange:function t(e){var n=this._view;return!!n&&Math.pow(e-n.x,2)<Math.pow(n.radius+n.hoverRadius,2)},inRange:function t(e,n){var i=this._view;if(i){for(var a=c.getAngleFromPoint(i,{x:e,y:n}),o=a.angle,r=a.distance,l=i.startAngle,s=i.endAngle;s<l;)s+=2*Math.PI;for(;s<o;)o-=2*Math.PI;for(;o<l;)o+=2*Math.PI;// Check if within the range of the open/close angle
var u=l<=o&&o<=s,d=r>=i.innerRadius&&r<=i.outerRadius;return u&&d}return!1},getCenterPoint:function t(){var e=this._view,n=(e.startAngle+e.endAngle)/2,i=(e.innerRadius+e.outerRadius)/2;return{x:e.x+Math.cos(n)*i,y:e.y+Math.sin(n)*i}},getArea:function t(){var e=this._view;return Math.PI*((e.endAngle-e.startAngle)/(2*Math.PI))*(Math.pow(e.outerRadius,2)-Math.pow(e.innerRadius,2))},tooltipPosition:function t(){var e=this._view,n=e.startAngle+(e.endAngle-e.startAngle)/2,i=(e.outerRadius-e.innerRadius)/2+e.innerRadius;return{x:e.x+Math.cos(n)*i,y:e.y+Math.sin(n)*i}},draw:function t(){var e=this._chart.ctx,n=this._view,i=n.startAngle,a=n.endAngle;e.beginPath(),e.arc(n.x,n.y,n.outerRadius,i,a),e.arc(n.x,n.y,n.innerRadius,a,i,!0),e.closePath(),e.strokeStyle=n.borderColor,e.lineWidth=n.borderWidth,e.fillStyle=n.backgroundColor,e.fill(),e.lineJoin="bevel",n.borderWidth&&e.stroke()}})},{26:26,27:27,46:46}],38:[function(t,e,n){var i=t(26),a=t(27),h=t(46),f=i.global;i._set("global",{elements:{line:{tension:.4,backgroundColor:f.defaultColor,borderWidth:3,borderColor:f.defaultColor,borderCapStyle:"butt",borderDash:[],borderDashOffset:0,borderJoinStyle:"miter",capBezierPoints:!0,fill:!0}}}),e.exports=a.extend({draw:function t(){var e=this,n=e._view,i=e._chart.ctx,a=n.spanGaps,o=e._children.slice(),r=f.elements.line,l=-1,s,u,d,c;for(// If we are looping, adding the first point again
e._loop&&o.length&&o.push(o[0]),i.save(),// Stroke Line Options
i.lineCap=n.borderCapStyle||r.borderCapStyle,// IE 9 and 10 do not support line dash
i.setLineDash&&i.setLineDash(n.borderDash||r.borderDash),i.lineDashOffset=n.borderDashOffset||r.borderDashOffset,i.lineJoin=n.borderJoinStyle||r.borderJoinStyle,i.lineWidth=n.borderWidth||r.borderWidth,i.strokeStyle=n.borderColor||f.defaultColor,// Stroke Line
i.beginPath(),l=-1,s=0;s<o.length;++s)u=o[s],d=h.previousItem(o,s),c=u._view,// First point moves to it's starting position no matter what
0===s?c.skip||(i.moveTo(c.x,c.y),l=s):(d=-1===l?d:o[l],c.skip||(l!==s-1&&!a||-1===l?
// There was a gap and this is the first point after the gap
i.moveTo(c.x,c.y):
// Line to next point
h.canvas.lineTo(i,d._view,u._view),l=s));i.stroke(),i.restore()}})},{26:26,27:27,46:46}],39:[function(t,e,n){function i(t){var e=this._view;return!!e&&Math.abs(t-e.x)<e.radius+e.hitRadius}function a(t){var e=this._view;return!!e&&Math.abs(t-e.y)<e.radius+e.hitRadius}var c=t(26),o=t(27),h=t(46),f=c.global.defaultColor;c._set("global",{elements:{point:{radius:3,pointStyle:"circle",backgroundColor:f,borderColor:f,borderWidth:1,
// Hover
hitRadius:1,hoverRadius:4,hoverBorderWidth:1}}}),e.exports=o.extend({inRange:function t(e,n){var i=this._view;return!!i&&Math.pow(e-i.x,2)+Math.pow(n-i.y,2)<Math.pow(i.hitRadius+i.radius,2)},inLabelRange:i,inXRange:i,inYRange:a,getCenterPoint:function t(){var e=this._view;return{x:e.x,y:e.y}},getArea:function t(){return Math.PI*Math.pow(this._view.radius,2)},tooltipPosition:function t(){var e=this._view;return{x:e.x,y:e.y,padding:e.radius+e.borderWidth}},draw:function t(e){var n=this._view,i=this._model,a=this._chart.ctx,o=n.pointStyle,r=n.rotation,l=n.radius,s=n.x,u=n.y,d=1.01;// 1.01 is margin for Accumulated error. (Especially Edge, IE.)
n.skip||// Clipping for Points.
(void 0===e||i.x>=e.left&&e.right*d>=i.x&&i.y>=e.top&&e.bottom*d>=i.y)&&(a.strokeStyle=n.borderColor||f,a.lineWidth=h.valueOrDefault(n.borderWidth,c.global.elements.point.borderWidth),a.fillStyle=n.backgroundColor||f,h.canvas.drawPoint(a,o,l,s,u,r))}})},{26:26,27:27,46:46}],40:[function(t,e,n){function s(t){return void 0!==t._view.width}
/**
       * Helper function to get the bounds of the bar regardless of the orientation
       * @param bar {Chart.Element.Rectangle} the bar
       * @return {Bounds} bounds of the bar
       * @private
       */function r(t){var e=t._view,n,i,a,o;if(s(t)){
// vertical
var r=e.width/2;n=e.x-r,i=e.x+r,a=Math.min(e.y,e.base),o=Math.max(e.y,e.base)}else{
// horizontal bar
var l=e.height/2;n=Math.min(e.x,e.base),i=Math.max(e.x,e.base),a=e.y-l,o=e.y+l}return{left:n,top:a,right:i,bottom:o}}var i=t(26),a=t(27);i._set("global",{elements:{rectangle:{backgroundColor:i.global.defaultColor,borderColor:i.global.defaultColor,borderSkipped:"bottom",borderWidth:0}}}),e.exports=a.extend({draw:function t(){function e(t){return b[(y+t)%4]}// Draw rectangle from 'startCorner'
var n=this._chart.ctx,i=this._view,a,o,r,l,s,u,d,c=i.borderWidth;// Canvas doesn't allow us to stroke inside the width so we can
// adjust the sizes to fit if we're setting a stroke on the line
if(d=i.horizontal?(
// horizontal bar
a=i.base,o=i.x,r=i.y-i.height/2,l=i.y+i.height/2,s=a<o?1:-1,u=1,i.borderSkipped||"left"):(
// bar
a=i.x-i.width/2,o=i.x+i.width/2,s=1,u=(r=i.y)<(l=i.base)?1:-1,i.borderSkipped||"bottom"),c){
// borderWidth shold be less than bar width and bar height.
var h=Math.min(Math.abs(a-o),Math.abs(r-l)),f=(c=h<c?h:c)/2,g=a+("left"!==d?f*s:0),p=o+("right"!==d?-f*s:0),m=r+("top"!==d?f*u:0),v=l+("bottom"!==d?-f*u:0);// not become a vertical line?
g!==p&&(r=m,l=v),// not become a horizontal line?
m!==v&&(a=g,o=p)}n.beginPath(),n.fillStyle=i.backgroundColor,n.strokeStyle=i.borderColor,n.lineWidth=c;// Corner points, from bottom-left to bottom-right clockwise
// | 1 2 |
// | 0 3 |
var b=[[a,l],[a,r],[o,r],[o,l]],x,y=["bottom","left","top","right"].indexOf(d,0);// Find first (starting) corner with fallback to 'bottom'
-1===y&&(y=0);var k=e(0);n.moveTo(k[0],k[1]);for(var w=1;w<4;w++)k=e(w),n.lineTo(k[0],k[1]);n.fill(),c&&n.stroke()},height:function t(){var e=this._view;return e.base-e.y},inRange:function t(e,n){var t=!1;if(this._view){var i=r(this);t=e>=i.left&&e<=i.right&&n>=i.top&&n<=i.bottom}return t},inLabelRange:function t(e,n){var i=this;if(!i._view)return!1;var a=!1,o=r(i);return a=s(i)?e>=o.left&&e<=o.right:n>=o.top&&n<=o.bottom},inXRange:function t(e){var n=r(this);return e>=n.left&&e<=n.right},inYRange:function t(e){var n=r(this);return e>=n.top&&e<=n.bottom},getCenterPoint:function t(){var e=this._view,n,i;return i=s(this)?(n=e.x,(e.y+e.base)/2):(n=(e.x+e.base)/2,e.y),{x:n,y:i}},getArea:function t(){var e=this._view;return e.width*Math.abs(e.y-e.base)},tooltipPosition:function t(){var e=this._view;return{x:e.x,y:e.y}}})},{26:26,27:27}],41:[function(t,e,n){e.exports={},e.exports.Arc=t(37),e.exports.Line=t(38),e.exports.Point=t(39),e.exports.Rectangle=t(40)},{37:37,38:38,39:39,40:40}],42:[function(t,e,n){var i=t(43),n=e.exports={
/**
         * Clears the entire canvas associated to the given `chart`.
         * @param {Chart} chart - The chart for which to clear the canvas.
         */
clear:function t(e){e.ctx.clearRect(0,0,e.width,e.height)},
/**
         * Creates a "path" for a rectangle with rounded corners at position (x, y) with a
         * given size (width, height) and the same `radius` for all corners.
         * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.
         * @param {Number} x - The x axis of the coordinate for the rectangle starting point.
         * @param {Number} y - The y axis of the coordinate for the rectangle starting point.
         * @param {Number} width - The rectangle's width.
         * @param {Number} height - The rectangle's height.
         * @param {Number} radius - The rounded amount (in pixels) for the four corners.
         * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?
         */
roundedRect:function t(e,n,i,a,o,r){if(r){
// NOTE(SB) `epsilon` helps to prevent minor artifacts appearing
// on Chrome when `r` is exactly half the height or the width.
var l=1e-7,s=Math.min(r,o/2-l,a/2-l);e.moveTo(n+s,i),e.lineTo(n+a-s,i),e.arcTo(n+a,i,n+a,i+s,s),e.lineTo(n+a,i+o-s),e.arcTo(n+a,i+o,n+a-s,i+o,s),e.lineTo(n+s,i+o),e.arcTo(n,i+o,n,i+o-s,s),e.lineTo(n,i+s),e.arcTo(n,i,n+s,i,s),e.closePath(),e.moveTo(n,i)}else e.rect(n,i,a,o)},drawPoint:function t(e,n,i,a,o,r){var l,s,u,d,c,h;if(r=r||0,!n||"object"!==_typeof(n)||"[object HTMLImageElement]"!==(l=n.toString())&&"[object HTMLCanvasElement]"!==l){if(!(isNaN(i)||i<=0)){switch(e.save(),e.translate(a,o),e.rotate(r*Math.PI/180),e.beginPath(),n){
// Default includes circle
default:e.arc(0,0,i,0,2*Math.PI),e.closePath();break;case"triangle":c=(s=3*i/Math.sqrt(3))*Math.sqrt(3)/2,e.moveTo(-s/2,c/3),e.lineTo(s/2,c/3),e.lineTo(0,-2*c/3),e.closePath();break;case"rect":h=1/Math.SQRT2*i,e.rect(-h,-h,2*h,2*h);break;case"rectRounded":var f=i/Math.SQRT2,g=-f,p=-f,m=Math.SQRT2*i;// NOTE(SB) the rounded rect implementation changed to use `arcTo`
// instead of `quadraticCurveTo` since it generates better results
// when rect is almost a circle. 0.425 (instead of 0.5) produces
// results visually closer to the previous impl.
this.roundedRect(e,g,p,m,m,.425*i);break;case"rectRot":h=1/Math.SQRT2*i,e.moveTo(-h,0),e.lineTo(0,h),e.lineTo(h,0),e.lineTo(0,-h),e.closePath();break;case"cross":e.moveTo(0,i),e.lineTo(0,-i),e.moveTo(-i,0),e.lineTo(i,0);break;case"crossRot":u=Math.cos(Math.PI/4)*i,d=Math.sin(Math.PI/4)*i,e.moveTo(-u,-d),e.lineTo(u,d),e.moveTo(-u,d),e.lineTo(u,-d);break;case"star":e.moveTo(0,i),e.lineTo(0,-i),e.moveTo(-i,0),e.lineTo(i,0),u=Math.cos(Math.PI/4)*i,d=Math.sin(Math.PI/4)*i,e.moveTo(-u,-d),e.lineTo(u,d),e.moveTo(-u,d),e.lineTo(u,-d);break;case"line":e.moveTo(-i,0),e.lineTo(i,0);break;case"dash":e.moveTo(0,0),e.lineTo(i,0);break}e.fill(),e.stroke(),e.restore()}}else e.drawImage(n,a-n.width/2,o-n.height/2,n.width,n.height)},clipArea:function t(e,n){e.save(),e.beginPath(),e.rect(n.left,n.top,n.right-n.left,n.bottom-n.top),e.clip()},unclipArea:function t(e){e.restore()},lineTo:function t(e,n,i,a){if(i.steppedLine)return"after"===i.steppedLine&&!a||"after"!==i.steppedLine&&a?e.lineTo(n.x,i.y):e.lineTo(i.x,n.y),void e.lineTo(i.x,i.y);i.tension?e.bezierCurveTo(a?n.controlPointPreviousX:n.controlPointNextX,a?n.controlPointPreviousY:n.controlPointNextY,a?i.controlPointNextX:i.controlPointPreviousX,a?i.controlPointNextY:i.controlPointPreviousY,i.x,i.y):e.lineTo(i.x,i.y)}};
/**
       * @namespace Chart.helpers.canvas
       */ // DEPRECATIONS
/**
       * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.
       * @namespace Chart.helpers.clear
       * @deprecated since version 2.7.0
       * @todo remove at version 3
       * @private
       */
i.clear=n.clear,
/**
       * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.
       * @namespace Chart.helpers.drawRoundedRectangle
       * @deprecated since version 2.7.0
       * @todo remove at version 3
       * @private
       */
i.drawRoundedRectangle=function(t){t.beginPath(),n.roundedRect.apply(n,arguments)}},{43:43}],43:[function(t,e,n){
/**
       * @namespace Chart.helpers
       */
var d={
/**
         * An empty function that can be used, for example, for optional callback.
         */
noop:function t(){},
/**
         * Returns a unique id, sequentially generated from a global variable.
         * @returns {Number}
         * @function
         */
uid:(i=0,function(){return i++}),
/**
         * Returns true if `value` is neither null nor undefined, else returns false.
         * @param {*} value - The value to test.
         * @returns {Boolean}
         * @since 2.7.0
         */
isNullOrUndef:function t(e){return null==e},
/**
         * Returns true if `value` is an array, else returns false.
         * @param {*} value - The value to test.
         * @returns {Boolean}
         * @function
         */
isArray:Array.isArray?Array.isArray:function(t){return"[object Array]"===Object.prototype.toString.call(t)},
/**
         * Returns true if `value` is an object (excluding null), else returns false.
         * @param {*} value - The value to test.
         * @returns {Boolean}
         * @since 2.7.0
         */
isObject:function t(e){return null!==e&&"[object Object]"===Object.prototype.toString.call(e)},
/**
         * Returns `value` if defined, else returns `defaultValue`.
         * @param {*} value - The value to return if defined.
         * @param {*} defaultValue - The value to return if `value` is undefined.
         * @returns {*}
         */
valueOrDefault:function t(e,n){return void 0===e?n:e},
/**
         * Returns value at the given `index` in array if defined, else returns `defaultValue`.
         * @param {Array} value - The array to lookup for value at `index`.
         * @param {Number} index - The index in `value` to lookup for value.
         * @param {*} defaultValue - The value to return if `value[index]` is undefined.
         * @returns {*}
         */
valueAtIndexOrDefault:function t(e,n,i){return d.valueOrDefault(d.isArray(e)?e[n]:e,i)},
/**
         * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
         * value returned by `fn`. If `fn` is not a function, this method returns undefined.
         * @param {Function} fn - The function to call.
         * @param {Array|undefined|null} args - The arguments with which `fn` should be called.
         * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.
         * @returns {*}
         */
callback:function t(e,n,i){if(e&&"function"==typeof e.call)return e.apply(i,n)},
/**
         * Note(SB) for performance sake, this method should only be used when loopable type
         * is unknown or in none intensive code (not called often and small loopable). Else
         * it's preferable to use a regular for() loop and save extra function calls.
         * @param {Object|Array} loopable - The object or array to be iterated.
         * @param {Function} fn - The function to call for each item.
         * @param {Object} [thisArg] - The value of `this` provided for the call to `fn`.
         * @param {Boolean} [reverse] - If true, iterates backward on the loopable.
         */
each:function t(e,n,i,a){var o,r,l;if(d.isArray(e))if(r=e.length,a)for(o=r-1;0<=o;o--)n.call(i,e[o],o);else for(o=0;o<r;o++)n.call(i,e[o],o);else if(d.isObject(e))for(r=(l=Object.keys(e)).length,o=0;o<r;o++)n.call(i,e[l[o]],l[o])},
/**
         * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
         * @see http://stackoverflow.com/a/14853974
         * @param {Array} a0 - The array to compare
         * @param {Array} a1 - The array to compare
         * @returns {Boolean}
         */
arrayEquals:function t(e,n){var i,a,o,r;if(!e||!n||e.length!==n.length)return!1;for(i=0,a=e.length;i<a;++i)if(o=e[i],r=n[i],o instanceof Array&&r instanceof Array){if(!d.arrayEquals(o,r))return!1}else if(o!==r)
// NOTE: two different object instances will never be equal: {x:20} != {x:20}
return!1;return!0},
/**
         * Returns a deep copy of `source` without keeping references on objects and arrays.
         * @param {*} source - The value to clone.
         * @returns {*}
         */
clone:function t(e){if(d.isArray(e))return e.map(d.clone);if(d.isObject(e)){for(var n={},i=Object.keys(e),a=i.length,o=0;o<a;++o)n[i[o]]=d.clone(e[i[o]]);return n}return e},
/**
         * The default merger when Chart.helpers.merge is called without merger option.
         * Note(SB): this method is also used by configMerge and scaleMerge as fallback.
         * @private
         */
_merger:function t(e,n,i,a){var o=n[e],r=i[e];d.isObject(o)&&d.isObject(r)?d.merge(o,r,a):n[e]=d.clone(r)},
/**
         * Merges source[key] in target[key] only if target[key] is undefined.
         * @private
         */
_mergerIf:function t(e,n,i){var a=n[e],o=i[e];d.isObject(a)&&d.isObject(o)?d.mergeIf(a,o):n.hasOwnProperty(e)||(n[e]=d.clone(o))},
/**
         * Recursively deep copies `source` properties into `target` with the given `options`.
         * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
         * @param {Object} target - The target object in which all sources are merged into.
         * @param {Object|Array(Object)} source - Object(s) to merge into `target`.
         * @param {Object} [options] - Merging options:
         * @param {Function} [options.merger] - The merge method (key, target, source, options)
         * @returns {Object} The `target` object.
         */
merge:function t(e,n,i){var a=d.isArray(n)?n:[n],o=a.length,t,r,l,s,u;if(!d.isObject(e))return e;for(t=(i=i||{}).merger||d._merger,r=0;r<o;++r)if(n=a[r],d.isObject(n))for(u=0,s=(l=Object.keys(n)).length;u<s;++u)t(l[u],e,n,i);return e},
/**
         * Recursively deep copies `source` properties into `target` *only* if not defined in target.
         * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
         * @param {Object} target - The target object in which all sources are merged into.
         * @param {Object|Array(Object)} source - Object(s) to merge into `target`.
         * @returns {Object} The `target` object.
         */
mergeIf:function t(e,n){return d.merge(e,n,{merger:d._mergerIf})},
/**
         * Applies the contents of two or more objects together into the first object.
         * @param {Object} target - The target object in which all objects are merged into.
         * @param {Object} arg1 - Object containing additional properties to merge in target.
         * @param {Object} argN - Additional objects containing properties to merge in target.
         * @returns {Object} The `target` object.
         */
extend:function t(i){for(var e=function t(e,n){i[n]=e},n=1,a=arguments.length;n<a;++n)d.each(arguments[n],e);return i},
/**
         * Basic javascript inheritance based on the model created in Backbone.js
         */
inherits:function t(e){var n=this,i=e&&e.hasOwnProperty("constructor")?e.constructor:function(){return n.apply(this,arguments)},a=function t(){this.constructor=i};return a.prototype=n.prototype,i.prototype=new a,i.extend=d.inherits,e&&d.extend(i.prototype,e),i.__super__=n.prototype,i}},i;// DEPRECATIONS
/**
       * Provided for backward compatibility, use Chart.helpers.callback instead.
       * @function Chart.helpers.callCallback
       * @deprecated since version 2.6.0
       * @todo remove at version 3
       * @private
       */
(e.exports=d).callCallback=d.callback,
/**
       * Provided for backward compatibility, use Array.prototype.indexOf instead.
       * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+
       * @function Chart.helpers.indexOf
       * @deprecated since version 2.7.0
       * @todo remove at version 3
       * @private
       */
d.indexOf=function(t,e,n){return Array.prototype.indexOf.call(t,e,n)},
/**
       * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.
       * @function Chart.helpers.getValueOrDefault
       * @deprecated since version 2.7.0
       * @todo remove at version 3
       * @private
       */
d.getValueOrDefault=d.valueOrDefault,
/**
       * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.
       * @function Chart.helpers.getValueAtIndexOrDefault
       * @deprecated since version 2.7.0
       * @todo remove at version 3
       * @private
       */
d.getValueAtIndexOrDefault=d.valueAtIndexOrDefault},{}],44:[function(t,e,n){var i=t(43),a={linear:function t(e){return e},easeInQuad:function t(e){return e*e},easeOutQuad:function t(e){return-e*(e-2)},easeInOutQuad:function t(e){return(e/=.5)<1?.5*e*e:-.5*(--e*(e-2)-1)},easeInCubic:function t(e){return e*e*e},easeOutCubic:function t(e){return(e-=1)*e*e+1},easeInOutCubic:function t(e){return(e/=.5)<1?.5*e*e*e:.5*((e-=2)*e*e+2)},easeInQuart:function t(e){return e*e*e*e},easeOutQuart:function t(e){return-((e-=1)*e*e*e-1)},easeInOutQuart:function t(e){return(e/=.5)<1?.5*e*e*e*e:-.5*((e-=2)*e*e*e-2)},easeInQuint:function t(e){return e*e*e*e*e},easeOutQuint:function t(e){return(e-=1)*e*e*e*e+1},easeInOutQuint:function t(e){return(e/=.5)<1?.5*e*e*e*e*e:.5*((e-=2)*e*e*e*e+2)},easeInSine:function t(e){return 1-Math.cos(e*(Math.PI/2))},easeOutSine:function t(e){return Math.sin(e*(Math.PI/2))},easeInOutSine:function t(e){return-.5*(Math.cos(Math.PI*e)-1)},easeInExpo:function t(e){return 0===e?0:Math.pow(2,10*(e-1))},easeOutExpo:function t(e){return 1===e?1:1-Math.pow(2,-10*e)},easeInOutExpo:function t(e){return 0===e?0:1===e?1:(e/=.5)<1?.5*Math.pow(2,10*(e-1)):.5*(2-Math.pow(2,-10*--e))},easeInCirc:function t(e){return 1<=e?e:-(Math.sqrt(1-e*e)-1)},easeOutCirc:function t(e){return Math.sqrt(1-(e-=1)*e)},easeInOutCirc:function t(e){return(e/=.5)<1?-.5*(Math.sqrt(1-e*e)-1):.5*(Math.sqrt(1-(e-=2)*e)+1)},easeInElastic:function t(e){var n=1.70158,i=0,a=1;return 0===e?0:1===e?1:(i||(i=.3),n=a<1?(a=1,i/4):i/(2*Math.PI)*Math.asin(1/a),-a*Math.pow(2,10*(e-=1))*Math.sin((e-n)*(2*Math.PI)/i))},easeOutElastic:function t(e){var n=1.70158,i=0,a=1;return 0===e?0:1===e?1:(i||(i=.3),n=a<1?(a=1,i/4):i/(2*Math.PI)*Math.asin(1/a),a*Math.pow(2,-10*e)*Math.sin((e-n)*(2*Math.PI)/i)+1)},easeInOutElastic:function t(e){var n=1.70158,i=0,a=1;return 0===e?0:2==(e/=.5)?1:(i||(i=.45),n=a<1?(a=1,i/4):i/(2*Math.PI)*Math.asin(1/a),e<1?a*Math.pow(2,10*(e-=1))*Math.sin((e-n)*(2*Math.PI)/i)*-.5:a*Math.pow(2,-10*(e-=1))*Math.sin((e-n)*(2*Math.PI)/i)*.5+1)},easeInBack:function t(e){var n=1.70158;return e*e*((n+1)*e-n)},easeOutBack:function t(e){var n=1.70158;return(e-=1)*e*((n+1)*e+n)+1},easeInOutBack:function t(e){var n=1.70158;return(e/=.5)<1?e*e*((1+(n*=1.525))*e-n)*.5:.5*((e-=2)*e*((1+(n*=1.525))*e+n)+2)},easeInBounce:function t(e){return 1-a.easeOutBounce(1-e)},easeOutBounce:function t(e){return e<1/2.75?7.5625*e*e:e<2/2.75?7.5625*(e-=1.5/2.75)*e+.75:e<2.5/2.75?7.5625*(e-=2.25/2.75)*e+.9375:7.5625*(e-=2.625/2.75)*e+.984375},easeInOutBounce:function t(e){return e<.5?.5*a.easeInBounce(2*e):.5*a.easeOutBounce(2*e-1)+.5}};
/**
       * Easing functions adapted from Robert Penner's easing equations.
       * @namespace Chart.helpers.easingEffects
       * @see http://www.robertpenner.com/easing/
       */e.exports={effects:a},// DEPRECATIONS
/**
       * Provided for backward compatibility, use Chart.helpers.easing.effects instead.
       * @function Chart.helpers.easingEffects
       * @deprecated since version 2.7.0
       * @todo remove at version 3
       * @private
       */
i.easingEffects=a},{43:43}],45:[function(t,e,n){var l=t(43);
/**
       * @alias Chart.helpers.options
       * @namespace
       */e.exports={
/**
         * Converts the given line height `value` in pixels for a specific font `size`.
         * @param {Number|String} value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
         * @param {Number} size - The font size (in pixels) used to resolve relative `value`.
         * @returns {Number} The effective line height in pixels (size * 1.2 if value is invalid).
         * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
         * @since 2.7.0
         */
toLineHeight:function t(e,n){var i=(""+e).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);if(!i||"normal"===i[1])return 1.2*n;switch(e=+i[2],i[3]){case"px":return e;case"%":e/=100;break;default:break}return n*e},
/**
         * Converts the given value into a padding object with pre-computed width/height.
         * @param {Number|Object} value - If a number, set the value to all TRBL component,
         *  else, if and object, use defined properties and sets undefined ones to 0.
         * @returns {Object} The padding values (top, right, bottom, left, width, height)
         * @since 2.7.0
         */
toPadding:function t(e){var n,i,a,o;return l.isObject(e)?(n=+e.top||0,i=+e.right||0,a=+e.bottom||0,o=+e.left||0):n=i=a=o=+e||0,{top:n,right:i,bottom:a,left:o,height:n+a,width:o+i}},
/**
         * Evaluates the given `inputs` sequentially and returns the first defined value.
         * @param {Array[]} inputs - An array of values, falling back to the last value.
         * @param {Object} [context] - If defined and the current value is a function, the value
         * is called with `context` as first argument and the result becomes the new input.
         * @param {Number} [index] - If defined and the current value is an array, the value
         * at `index` become the new input.
         * @since 2.7.0
         */
resolve:function t(e,n,i){var a,o,r;for(a=0,o=e.length;a<o;++a)if(void 0!==(r=e[a])&&(void 0!==n&&"function"==typeof r&&(r=r(n)),void 0!==i&&l.isArray(r)&&(r=r[i]),void 0!==r))return r}}},{43:43}],46:[function(t,e,n){e.exports=t(43),e.exports.easing=t(44),e.exports.canvas=t(42),e.exports.options=t(45)},{42:42,43:43,44:44,45:45}],47:[function(t,e,n){
/**
       * Platform fallback implementation (minimal).
       * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939
       */
e.exports={acquireContext:function t(e){return e&&e.canvas&&(
// Support for any object associated to a canvas (including a context2d)
e=e.canvas),e&&e.getContext("2d")||null}}},{}],48:[function(t,e,n){
/**
       * The "used" size is the final value of a dimension property after all calculations have
       * been performed. This method uses the computed style of `element` but returns undefined
       * if the computed style is not expressed in pixels. That can happen in some cases where
       * `element` has a size relative to its parent and this last one is not yet displayed,
       * for example because of `display: none` on a parent node.
       * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
       * @returns {Number} Size in pixels or undefined if unknown.
       */
function l(t,e){var n=m.getStyle(t,e),i=n&&n.match(/^(\d+)(\.\d+)?px$/);return i?Number(i[1]):void 0}
/**
       * Initializes the canvas style and render size without modifying the canvas display size,
       * since responsiveness is handled by the controller.resize() method. The config is used
       * to determine the aspect ratio to apply in case no explicit height has been specified.
       */function a(t,e){var n=t.style,i=t.getAttribute("height"),a=t.getAttribute("width");// NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it
// returns null or '' if no explicit value has been set to the canvas attribute.
if(// Chart.js modifies some canvas values that we want to restore on destroy
t[v]={initial:{height:i,width:a,style:{display:n.display,height:n.height,width:n.width}}},// Force canvas to display as block to avoid extra space caused by inline
// elements, which would interfere with the responsive resize process.
// https://github.com/chartjs/Chart.js/issues/2538
n.display=n.display||"block",null===a||""===a){var o=l(t,"width");void 0!==o&&(t.width=o)}if(null===i||""===i)if(""===t.style.height)
// If no explicit render height and style height, let's apply the aspect ratio,
// which one can be specified by the user but also by charts as default option
// (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.
t.height=t.width/(e.options.aspectRatio||2);else{var r=l(t,"height");void 0!==o&&(t.height=r)}return t}
/**
       * Detects support for options object argument in addEventListener.
       * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
       * @private
       */function s(t,e,n){t.addEventListener(e,n,C)}function u(t,e,n){t.removeEventListener(e,n,C)}function o(t,e,n,i,a){return{type:t,chart:e,native:a||null,x:void 0!==n?n:null,y:void 0!==i?i:null}}function d(t,e){var n=w[t.type]||t.type,i=m.getRelativePosition(t,e);return o(n,e,i.x,i.y,t)}function r(t,e){var n=!1,i=[];return function(){i=Array.prototype.slice.call(arguments),e=e||this,n||(n=!0,m.requestAnimFrame.call(window,function(){n=!1,t.apply(e,i)}))}}// Implementation based on https://github.com/marcj/css-element-queries
function c(e){var n=document.createElement("div"),t=b+"size-monitor",i=1e6,a="position:absolute;left:0;top:0;right:0;bottom:0;overflow:hidden;pointer-events:none;visibility:hidden;z-index:-1;";n.style.cssText=a,n.className=t,n.innerHTML='<div class="'+t+'-expand" style="'+a+'"><div style="position:absolute;width:'+i+"px;height:"+i+'px;left:0;top:0"></div></div><div class="'+t+'-shrink" style="'+a+'"><div style="position:absolute;width:200%;height:200%;left:0; top:0"></div></div>';var o=n.childNodes[0],r=n.childNodes[1];n._reset=function(){o.scrollLeft=i,o.scrollTop=i,r.scrollLeft=i,r.scrollTop=i};var l=function t(){n._reset(),e()};return s(o,"scroll",l.bind(o,"expand")),s(r,"scroll",l.bind(r,"shrink")),n}// https://davidwalsh.name/detect-node-insertion
function h(e,n){var t=e[v]||(e[v]={}),i=t.renderProxy=function(t){t.animationName===y&&n()};m.each(k,function(t){s(e,t,i)}),// #4737: Chrome might skip the CSS animation when the CSS_RENDER_MONITOR class
// is removed then added back immediately (same animation frame?). Accessing the
// `offsetParent` property will force a reflow and re-evaluate the CSS animation.
// https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics
// https://github.com/chartjs/Chart.js/issues/4737
t.reflow=!!e.offsetParent,e.classList.add(x)}function i(e){var t=e[v]||{},n=t.renderProxy;n&&(m.each(k,function(t){u(e,t,n)}),delete t.renderProxy),e.classList.remove(x)}function f(e,t,n){var i=e[v]||(e[v]={}),a=i.resizer=c(r(function(){if(i.resizer)return t(o("resize",n))}));// Let's keep track of this added resizer and thus avoid DOM query when removing it.
// The resizer needs to be attached to the node parent, so we first need to be
// sure that `node` is attached to the DOM before injecting the resizer element.
h(e,function(){if(i.resizer){var t=e.parentNode;t&&t!==a.parentNode&&t.insertBefore(a,t.firstChild),// The container size might have changed, let's reset the resizer state.
a._reset()}})}function g(t){var e=t[v]||{},n=e.resizer;delete e.resizer,i(t),n&&n.parentNode&&n.parentNode.removeChild(n)}function p(t,e){
// http://stackoverflow.com/q/3922139
var n=t._style||document.createElement("style");t._style||(e="/* Chart.js */\n"+e,(t._style=n).setAttribute("type","text/css"),document.getElementsByTagName("head")[0].appendChild(n)),n.appendChild(document.createTextNode(e))}var m=t(46),v="$chartjs",b="chartjs-",x=b+"render-monitor",y=b+"render-animation",k=["animationstart","webkitAnimationStart"],w={touchstart:"mousedown",touchmove:"mousemove",touchend:"mouseup",pointerenter:"mouseenter",pointerdown:"mousedown",pointermove:"mousemove",pointerup:"mouseup",pointerleave:"mouseout",pointerout:"mouseout"},M,C=!!function(){var e=!1;try{var t=Object.defineProperty({},"passive",{get:function t(){e=!0}});window.addEventListener("e",null,t)}catch(t){// continue regardless of error
}return e}()&&{passive:!0};e.exports={
/**
         * This property holds whether this platform is enabled for the current environment.
         * Currently used by platform.js to select the proper implementation.
         * @private
         */
_enabled:"undefined"!=typeof window&&"undefined"!=typeof document,initialize:function t(){var e="from{opacity:0.99}to{opacity:1}";p(this,// DOM rendering detection
// https://davidwalsh.name/detect-node-insertion
"@-webkit-keyframes "+y+"{"+e+"}@keyframes "+y+"{"+e+"}."+x+"{-webkit-animation:"+y+" 0.001s;animation:"+y+" 0.001s;}")},acquireContext:function t(e,n){"string"==typeof e?e=document.getElementById(e):e.length&&(
// Support for array based queries (such as jQuery)
e=e[0]),e&&e.canvas&&(
// Support for any object associated to a canvas (including a context2d)
e=e.canvas);// To prevent canvas fingerprinting, some add-ons undefine the getContext
// method, for example: https://github.com/kkapsner/CanvasBlocker
// https://github.com/chartjs/Chart.js/issues/2807
var i=e&&e.getContext&&e.getContext("2d");// `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is
// inside an iframe or when running in a protected environment. We could guess the
// types from their toString() value but let's keep things flexible and assume it's
// a sufficient condition if the item has a context2D which has item as `canvas`.
// https://github.com/chartjs/Chart.js/issues/3887
// https://github.com/chartjs/Chart.js/issues/4102
// https://github.com/chartjs/Chart.js/issues/4152
return i&&i.canvas===e?(a(e,n),i):null},releaseContext:function t(e){var n=e.canvas;if(n[v]){var i=n[v].initial;["height","width"].forEach(function(t){var e=i[t];m.isNullOrUndef(e)?n.removeAttribute(t):n.setAttribute(t,e)}),m.each(i.style||{},function(t,e){n.style[e]=t}),// The canvas render size might have been changed (and thus the state stack discarded),
// we can't use save() and restore() to restore the initial state. So make sure that at
// least the canvas context is reset to the default state by setting the canvas width.
// https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html
n.width=n.width,delete n[v]}},addEventListener:function t(e,n,i){var a=e.canvas;if("resize"!==n){var o=i[v]||(i[v]={}),r,l;s(a,n,(o.proxies||(o.proxies={}))[e.id+"_"+n]=function(t){i(d(t,e))})}else
// Note: the resize event is not supported on all browsers.
f(a,i,e)},removeEventListener:function t(e,n,i){var a=e.canvas;if("resize"!==n){var o,r,l=((i[v]||{}).proxies||{})[e.id+"_"+n];l&&u(a,n,l)}else
// Note: the resize event is not supported on all browsers.
g(a,i)}},// DEPRECATIONS
/**
       * Provided for backward compatibility, use EventTarget.addEventListener instead.
       * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
       * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
       * @function Chart.helpers.addEvent
       * @deprecated since version 2.7.0
       * @todo remove at version 3
       * @private
       */
m.addEvent=s,
/**
       * Provided for backward compatibility, use EventTarget.removeEventListener instead.
       * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
       * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener
       * @function Chart.helpers.removeEvent
       * @deprecated since version 2.7.0
       * @todo remove at version 3
       * @private
       */
m.removeEvent=u},{46:46}],49:[function(t,e,n){var i=t(46),a=t(47),o=t(48),r=o._enabled?o:a;
/**
       * @namespace Chart.platform
       * @see https://chartjs.gitbooks.io/proposals/content/Platform.html
       * @since 2.4.0
       */
e.exports=i.extend({
/**
         * @since 2.7.0
         */
initialize:function t(){},
/**
         * Called at chart construction time, returns a context2d instance implementing
         * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.
         * @param {*} item - The native item from which to acquire context (platform specific)
         * @param {Object} options - The chart options
         * @returns {CanvasRenderingContext2D} context2d instance
         */
acquireContext:function t(){},
/**
         * Called at chart destruction time, releases any resources associated to the context
         * previously returned by the acquireContext() method.
         * @param {CanvasRenderingContext2D} context - The context2d instance
         * @returns {Boolean} true if the method succeeded, else false
         */
releaseContext:function t(){},
/**
         * Registers the specified listener on the given chart.
         * @param {Chart} chart - Chart from which to listen for event
         * @param {String} type - The ({@link IEvent}) type to listen for
         * @param {Function} listener - Receives a notification (an object that implements
         * the {@link IEvent} interface) when an event of the specified type occurs.
         */
addEventListener:function t(){},
/**
         * Removes the specified listener previously registered with addEventListener.
         * @param {Chart} chart -Chart from which to remove the listener
         * @param {String} type - The ({@link IEvent}) type to remove
         * @param {Function} listener - The listener function to remove from the event target.
         */
removeEventListener:function t(){}},r)},{46:46,47:47,48:48}],50:[function(t,e,n){e.exports={},e.exports.filler=t(51),e.exports.legend=t(52),e.exports.title=t(53)},{51:51,52:52,53:53}],51:[function(t,e,n){// @todo if (fill[0] === '#')
function d(t,e,n){var i=t._model||{},a=i.fill,o;if(void 0===a&&(a=!!i.backgroundColor),!1===a||null===a)return!1;if(!0===a)return"origin";if(o=parseFloat(a,10),isFinite(o)&&Math.floor(o)===o)return"-"!==a[0]&&"+"!==a[0]||(o=e+o),!(o===e||o<0||n<=o)&&o;switch(a){
// compatibility
case"bottom":return"start";case"top":return"end";case"zero":return"origin";
// supported boundaries
case"origin":case"start":case"end":return a;
// invalid fill values
default:return!1}}function c(t){var e=t.el._model||{},n=t.el._scale||{},i=t.fill,a=null,o;if(isFinite(i))return null;// Backward compatibility: until v3, we still need to support boundary values set on
// the model (scaleTop, scaleBottom and scaleZero) because some external plugins and
// controllers might still use it (e.g. the Smith chart).
if("start"===i?a=void 0===e.scaleBottom?n.bottom:e.scaleBottom:"end"===i?a=void 0===e.scaleTop?n.top:e.scaleTop:void 0!==e.scaleZero?a=e.scaleZero:n.getBasePosition?a=n.getBasePosition():n.getBasePixel&&(a=n.getBasePixel()),null!=a){if(void 0!==a.x&&void 0!==a.y)return a;if("number"==typeof a&&isFinite(a))return{x:(o=n.isHorizontal())?a:null,y:o?null:a}}return null}function h(t,e,n){var i,a=t[e].fill,o=[e],r;if(!n)return a;for(;!1!==a&&-1===o.indexOf(a);){if(!isFinite(a))return a;if(!(r=t[a]))return!1;if(r.visible)return a;o.push(a),a=r.fill}return!1}function f(t){var e=t.fill,n="dataset";return!1===e?null:(isFinite(e)||(n="boundary"),i[n](t))}function x(t){return t&&!t.skip}function y(t,e,n,i,a){var o;if(i&&a){for(// building first area curve (normal)
t.moveTo(e[0].x,e[0].y),o=1;o<i;++o)v.canvas.lineTo(t,e[o-1],e[o]);// joining the two area curves
// building opposite area curve (reverse)
for(t.lineTo(n[a-1].x,n[a-1].y),o=a-1;0<o;--o)v.canvas.lineTo(t,n[o],n[o-1],!0)}}function g(t,e,n,i,a,o){var r=e.length,l=i.spanGaps,s=[],u=[],d=0,c=0,h,f,g,p,m,v,b;for(t.beginPath(),h=0,f=r+!!o;h<f;++h)m=n(p=e[g=h%r]._view,g,i),v=x(p),b=x(m),v&&b?(d=s.push(p),c=u.push(m)):d&&c&&(l?(v&&s.push(p),b&&u.push(m)):(y(t,s,u,d,c),d=c=0,s=[],u=[]));y(t,s,u,d,c),t.closePath(),t.fillStyle=a,t.fill()}var p=t(26),m=t(41),v=t(46);p._set("global",{plugins:{filler:{propagate:!0}}});var i={dataset:function t(e){var n=e.fill,i=e.chart,a=i.getDatasetMeta(n),o,r=a&&i.isDatasetVisible(n)&&a.dataset._children||[],l=r.length||0;return l?function(t,e){return e<l&&r[e]._view||null}:null},boundary:function t(e){var t=e.boundary,n=t?t.x:null,i=t?t.y:null;return function(t){return{x:null===n?t.x:n,y:null===i?t.y:i}}}};e.exports={id:"filler",afterDatasetsUpdate:function t(e,n){var i=(e.data.datasets||[]).length,a=n.propagate,o=[],r,l,s,u;for(l=0;l<i;++l)u=null,(s=(r=e.getDatasetMeta(l)).dataset)&&s._model&&s instanceof m.Line&&(u={visible:e.isDatasetVisible(l),fill:d(s,l,i),chart:e,el:s}),r.$filler=u,o.push(u);for(l=0;l<i;++l)(u=o[l])&&(u.fill=h(o,l,a),u.boundary=c(u),u.mapper=f(u))},beforeDatasetDraw:function t(e,n){var i=n.meta.$filler;if(i){var a=e.ctx,o=i.el,r=o._view,l=o._children||[],s=i.mapper,u=r.backgroundColor||p.global.defaultColor;s&&u&&l.length&&(v.canvas.clipArea(a,e.chartArea),g(a,l,s,r,u,o._loop),v.canvas.unclipArea(a))}}}},{26:26,41:41,46:46}],52:[function(t,e,n){
/**
       * Helper function to get the box width based on the usePointStyle option
       * @param labelopts {Object} the label options on the legend
       * @param fontSize {Number} the label font size
       * @return {Number} width of the color box area
       */
function M(t,e){return t.usePointStyle?e*Math.SQRT2:t.boxWidth}
/**
       * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
       */function a(t,e){var n=new l({ctx:t.ctx,options:e,chart:t});o.configure(t,n,e),o.addBox(t,n),t.legend=n}var C=t(26),i=t(27),S=t(46),o=t(31),r=S.noop;C._set("global",{legend:{display:!0,position:"top",fullWidth:!0,reverse:!1,weight:1e3,
// a callback that will handle
onClick:function t(e,n){var i=n.datasetIndex,a=this.chart,o=a.getDatasetMeta(i);// See controller.isDatasetVisible comment
o.hidden=null===o.hidden?!a.data.datasets[i].hidden:null,// We hid a dataset ... rerender the chart
a.update()},onHover:null,labels:{boxWidth:40,padding:10,
// Generates labels shown in the legend
// Valid properties to return:
// text : text to display
// fillStyle : fill of coloured box
// strokeStyle: stroke of coloured box
// hidden : if this legend item refers to a hidden item
// lineCap : cap style for line
// lineDash
// lineDashOffset :
// lineJoin :
// lineWidth :
generateLabels:function t(n){var e=n.data;return S.isArray(e.datasets)?e.datasets.map(function(t,e){return{text:t.label,fillStyle:S.isArray(t.backgroundColor)?t.backgroundColor[0]:t.backgroundColor,hidden:!n.isDatasetVisible(e),lineCap:t.borderCapStyle,lineDash:t.borderDash,lineDashOffset:t.borderDashOffset,lineJoin:t.borderJoinStyle,lineWidth:t.borderWidth,strokeStyle:t.borderColor,pointStyle:t.pointStyle,
// Below is extra data used for toggling the datasets
datasetIndex:e}},this):[]}}},legendCallback:function t(e){var n=[];n.push('<ul class="'+e.id+'-legend">');for(var i=0;i<e.data.datasets.length;i++)n.push('<li><span style="background-color:'+e.data.datasets[i].backgroundColor+'"></span>'),e.data.datasets[i].label&&n.push(e.data.datasets[i].label),n.push("</li>");return n.push("</ul>"),n.join("")}});var l=i.extend({initialize:function t(e){S.extend(this,e),// Contains hit boxes for each dataset (in dataset order)
this.legendHitBoxes=[],// Are we in doughnut mode which has a different data type
this.doughnutMode=!1},
// These methods are ordered by lifecycle. Utilities then follow.
// Any function defined here is inherited by all legend types.
// Any function can be extended by the legend type
beforeUpdate:r,update:function t(e,n,i){var a=this;// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
return a.beforeUpdate(),// Absorb the master measurements
a.maxWidth=e,a.maxHeight=n,a.margins=i,// Dimensions
a.beforeSetDimensions(),a.setDimensions(),a.afterSetDimensions(),// Labels
a.beforeBuildLabels(),a.buildLabels(),a.afterBuildLabels(),// Fit
a.beforeFit(),a.fit(),a.afterFit(),//
a.afterUpdate(),a.minSize},afterUpdate:r,
//
beforeSetDimensions:r,setDimensions:function t(){var e=this;// Set the unconstrained dimension before label rotation
e.isHorizontal()?(
// Reset position before calculating rotation
e.width=e.maxWidth,e.left=0,e.right=e.width):(e.height=e.maxHeight,// Reset position before calculating rotation
e.top=0,e.bottom=e.height),// Reset padding
e.paddingLeft=0,e.paddingTop=0,e.paddingRight=0,e.paddingBottom=0,// Reset minSize
e.minSize={width:0,height:0}},afterSetDimensions:r,
//
beforeBuildLabels:r,buildLabels:function t(){var e=this,n=e.options.labels||{},i=S.callback(n.generateLabels,[e.chart],e)||[];n.filter&&(i=i.filter(function(t){return n.filter(t,e.chart.data)})),e.options.reverse&&i.reverse(),e.legendItems=i},afterBuildLabels:r,
//
beforeFit:r,fit:function t(){var a=this,e=a.options,o=e.labels,n=e.display,r=a.ctx,i=C.global,l=S.valueOrDefault,s=l(o.fontSize,i.defaultFontSize),u=l(o.fontStyle,i.defaultFontStyle),d=l(o.fontFamily,i.defaultFontFamily),c=S.fontString(s,u,d),h=a.legendHitBoxes=[],f=a.minSize,g=a.isHorizontal();// Increase sizes here
if(// fill all the width
f.height=g?(f.width=a.maxWidth,n?10:0):(f.width=n?10:0,a.maxHeight),n)if(r.font=c,g){
// Labels
// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one
var p=a.lineWidths=[0],m=a.legendItems.length?s+o.padding:0;r.textAlign="left",r.textBaseline="top",S.each(a.legendItems,function(t,e){var n,i=M(o,s)+s/2+r.measureText(t.text).width;p[p.length-1]+i+o.padding>=a.width&&(m+=s+o.padding,p[p.length]=a.left),// Store the hitbox width and height here. Final position will be updated in `draw`
h[e]={left:0,top:0,width:i,height:s},p[p.length-1]+=i+o.padding}),f.height+=m}else{var v=o.padding,b=a.columnWidths=[],x=o.padding,y=0,k=0,w=s+v;S.each(a.legendItems,function(t,e){var n,i=M(o,s)+s/2+r.measureText(t.text).width;// If too tall, go to new column
k+w>f.height&&(x+=y+o.padding,b.push(y),k=// previous column width
y=0),// Get max width
y=Math.max(y,i),k+=w,// Store the hitbox width and height here. Final position will be updated in `draw`
h[e]={left:0,top:0,width:i,height:s}}),x+=y,b.push(y),f.width+=x}a.width=f.width,a.height=f.height},afterFit:r,
// Shared Methods
isHorizontal:function t(){return"top"===this.options.position||"bottom"===this.options.position},
// Actually draw the legend on the canvas
draw:function t(){var r=this,u=r.options,l=u.labels,d=C.global,c=d.elements.line,s=r.width,h=r.lineWidths;if(u.display){var f=r.ctx,g=S.valueOrDefault,e=g(l.fontColor,d.defaultFontColor),p=g(l.fontSize,d.defaultFontSize),n=g(l.fontStyle,d.defaultFontStyle),i=g(l.fontFamily,d.defaultFontFamily),a=S.fontString(p,n,i),m;// Canvas setup
f.textAlign="left",f.textBaseline="middle",f.lineWidth=.5,f.strokeStyle=e,// for strikethrough effect
f.fillStyle=e,// render in correct colour
f.font=a;var v=M(l,p),b=r.legendHitBoxes,x=function t(e,n,i){if(!(isNaN(v)||v<=0)){// Set the ctx for the box
f.save(),f.fillStyle=g(i.fillStyle,d.defaultColor),f.lineCap=g(i.lineCap,c.borderCapStyle),f.lineDashOffset=g(i.lineDashOffset,c.borderDashOffset),f.lineJoin=g(i.lineJoin,c.borderJoinStyle),f.lineWidth=g(i.lineWidth,c.borderWidth),f.strokeStyle=g(i.strokeStyle,d.defaultColor);var a=0===g(i.lineWidth,c.borderWidth);if(f.setLineDash&&
// IE 9 and 10 do not support line dash
f.setLineDash(g(i.lineDash,c.borderDash)),u.labels&&u.labels.usePointStyle){
// Recalculate x and y for drawPoint() because its expecting
// x and y to be center of figure (instead of top left)
var o=p*Math.SQRT2/2,r=o/Math.SQRT2,l=e+r,s=n+r;// Draw pointStyle as legend symbol
S.canvas.drawPoint(f,i.pointStyle,o,l,s)}else
// Draw box as legend symbol
a||f.strokeRect(e,n,v,p),f.fillRect(e,n,v,p);f.restore()}},y=function t(e,n,i,a){var o=p/2,r=v+o+e,l=n+o;f.fillText(i.text,r,l),i.hidden&&(
// Strikethrough the text if hidden
f.beginPath(),f.lineWidth=2,f.moveTo(r,l),f.lineTo(r+a,l),f.stroke())},k=r.isHorizontal();m=k?{x:r.left+(s-h[0])/2,y:r.top+l.padding,line:0}:{x:r.left+l.padding,y:r.top+l.padding,line:0};var w=p+l.padding;S.each(r.legendItems,function(t,e){var n=f.measureText(t.text).width,i=v+p/2+n,a=m.x,o=m.y;k?s<=a+i&&(o=m.y+=w,m.line++,a=m.x=r.left+(s-h[m.line])/2):o+w>r.bottom&&(a=m.x=a+r.columnWidths[m.line]+l.padding,o=m.y=r.top+l.padding,m.line++),x(a,o,t),b[e].left=a,b[e].top=o,// Fill the actual label
y(a,o,t,n),k?m.x+=i+l.padding:m.y+=w})}},
/**
         * Handle an event
         * @private
         * @param {IEvent} event - The event to handle
         * @return {Boolean} true if a change occured
         */
handleEvent:function t(e){var n=this,i=n.options,a="mouseup"===e.type?"click":e.type,o=!1;if("mousemove"===a){if(!i.onHover)return}else{if("click"!==a)return;// Chart event already has relative position in it
if(!i.onClick)return}var r=e.x,l=e.y;if(r>=n.left&&r<=n.right&&l>=n.top&&l<=n.bottom)for(
// See if we are touching one of the dataset boxes
var s=n.legendHitBoxes,u=0;u<s.length;++u){var d=s[u];if(r>=d.left&&r<=d.left+d.width&&l>=d.top&&l<=d.top+d.height){
// Touching an element
if("click"===a){
// use e.native for backwards compatibility
i.onClick.call(n,e.native,n.legendItems[u]),o=!0;break}if("mousemove"===a){
// use e.native for backwards compatibility
i.onHover.call(n,e.native,n.legendItems[u]),o=!0;break}}}return o}});e.exports={id:"legend",
/**
         * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making
         * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part of
         * the plugin, which one will be re-exposed in the chart.js file.
         * https://github.com/chartjs/Chart.js/pull/2640
         * @private
         */
_element:l,beforeInit:function t(e){var n=e.options.legend;n&&a(e,n)},beforeUpdate:function t(e){var n=e.options.legend,i=e.legend;n?(S.mergeIf(n,C.global.legend),i?(o.configure(e,i,n),i.options=n):a(e,n)):i&&(o.removeBox(e,i),delete e.legend)},afterEvent:function t(e,n){var i=e.legend;i&&i.handleEvent(n)}}},{26:26,27:27,31:31,46:46}],53:[function(t,e,n){function a(t,e){var n=new l({ctx:t.ctx,options:e,chart:t});o.configure(t,n,e),o.addBox(t,n),t.titleBlock=n}var M=t(26),i=t(27),C=t(46),o=t(31),r=C.noop;M._set("global",{title:{display:!1,fontStyle:"bold",fullWidth:!0,lineHeight:1.2,padding:10,position:"top",text:"",weight:2e3}});
/**
       * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
       */
var l=i.extend({initialize:function t(e){var n=this;C.extend(n,e),// Contains hit boxes for each dataset (in dataset order)
n.legendHitBoxes=[]},
// These methods are ordered by lifecycle. Utilities then follow.
beforeUpdate:r,update:function t(e,n,i){var a=this;// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
return a.beforeUpdate(),// Absorb the master measurements
a.maxWidth=e,a.maxHeight=n,a.margins=i,// Dimensions
a.beforeSetDimensions(),a.setDimensions(),a.afterSetDimensions(),// Labels
a.beforeBuildLabels(),a.buildLabels(),a.afterBuildLabels(),// Fit
a.beforeFit(),a.fit(),a.afterFit(),//
a.afterUpdate(),a.minSize},afterUpdate:r,
//
beforeSetDimensions:r,setDimensions:function t(){var e=this;// Set the unconstrained dimension before label rotation
e.isHorizontal()?(
// Reset position before calculating rotation
e.width=e.maxWidth,e.left=0,e.right=e.width):(e.height=e.maxHeight,// Reset position before calculating rotation
e.top=0,e.bottom=e.height),// Reset padding
e.paddingLeft=0,e.paddingTop=0,e.paddingRight=0,e.paddingBottom=0,// Reset minSize
e.minSize={width:0,height:0}},afterSetDimensions:r,
//
beforeBuildLabels:r,buildLabels:r,afterBuildLabels:r,
//
beforeFit:r,fit:function t(){var e=this,n=C.valueOrDefault,i=e.options,a=i.display,o=n(i.fontSize,M.global.defaultFontSize),r=e.minSize,l=C.isArray(i.text)?i.text.length:1,s=C.options.toLineHeight(i.lineHeight,o),u=a?l*s+2*i.padding:0;e.isHorizontal()?(r.width=e.maxWidth,// fill all the width
r.height=u):(r.width=u,r.height=e.maxHeight),e.width=r.width,e.height=r.height},afterFit:r,
// Shared Methods
isHorizontal:function t(){var e=this.options.position;return"top"===e||"bottom"===e},
// Actually draw the title block on the canvas
draw:function t(){var e=this,n=e.ctx,i=C.valueOrDefault,a=e.options,o=M.global;if(a.display){var r=i(a.fontSize,o.defaultFontSize),l=i(a.fontStyle,o.defaultFontStyle),s=i(a.fontFamily,o.defaultFontFamily),u=C.fontString(r,l,s),d=C.options.toLineHeight(a.lineHeight,r),c=d/2+a.padding,h=0,f=e.top,g=e.left,p=e.bottom,m=e.right,v,b,x;n.fillStyle=i(a.fontColor,o.defaultFontColor),// render in correct colour
n.font=u,// Horizontal
e.isHorizontal()?(b=g+(m-g)/2,// midpoint of the width
x=f+c,v=m-g):(b="left"===a.position?g+c:m-c,x=f+(p-f)/2,v=p-f,h=Math.PI*("left"===a.position?-.5:.5)),n.save(),n.translate(b,x),n.rotate(h),n.textAlign="center",n.textBaseline="middle";var y=a.text;if(C.isArray(y))for(var k=0,w=0;w<y.length;++w)n.fillText(y[w],0,k,v),k+=d;else n.fillText(y,0,0,v);n.restore()}}});e.exports={id:"title",
/**
         * Backward compatibility: since 2.1.5, the title is registered as a plugin, making
         * Chart.Title obsolete. To avoid a breaking change, we export the Title as part of
         * the plugin, which one will be re-exposed in the chart.js file.
         * https://github.com/chartjs/Chart.js/pull/2640
         * @private
         */
_element:l,beforeInit:function t(e){var n=e.options.title;n&&a(e,n)},beforeUpdate:function t(e){var n=e.options.title,i=e.titleBlock;n?(C.mergeIf(n,M.global.title),i?(o.configure(e,i,n),i.options=n):a(e,n)):i&&(o.removeBox(e,i),delete e.titleBlock)}}},{26:26,27:27,31:31,46:46}],54:[function(t,e,n){var i=t(33),a=t(34);e.exports=function(){
// Default config for a category scale
var t={position:"bottom"},e=i.extend({
/**
          * Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those
          * else fall back to data.labels
          * @private
          */
getLabels:function t(){var e=this.chart.data;return this.options.labels||(this.isHorizontal()?e.xLabels:e.yLabels)||e.labels},determineDataLimits:function t(){var e=this,n=e.getLabels(),i;e.minIndex=0,e.maxIndex=n.length-1,void 0!==e.options.ticks.min&&(
// user specified min value
i=n.indexOf(e.options.ticks.min),e.minIndex=-1!==i?i:e.minIndex),void 0!==e.options.ticks.max&&(
// user specified max value
i=n.indexOf(e.options.ticks.max),e.maxIndex=-1!==i?i:e.maxIndex),e.min=n[e.minIndex],e.max=n[e.maxIndex]},buildTicks:function t(){var e=this,n=e.getLabels();// If we are viewing some subset of labels, slice the original array
e.ticks=0===e.minIndex&&e.maxIndex===n.length-1?n:n.slice(e.minIndex,e.maxIndex+1)},getLabelForIndex:function t(e,n){var i=this,a=i.chart.data,o=i.isHorizontal();return a.yLabels&&!o?i.getRightValue(a.datasets[n].data[e]):i.ticks[e-i.minIndex]},
// Used to get data value locations.  Value can either be an index or a numerical value
getPixelForValue:function t(e,n){var i=this,a=i.options.offset,o=Math.max(i.maxIndex+1-i.minIndex-(a?0:1),1),r;if(null!=e&&(r=i.isHorizontal()?e.x:e.y),void 0!==r||void 0!==e&&isNaN(n)){var l;e=r||e;var s=i.getLabels().indexOf(e);n=-1!==s?s:n}if(i.isHorizontal()){var u=i.width/o,d=u*(n-i.minIndex);return a&&(d+=u/2),i.left+Math.round(d)}var c=i.height/o,h=c*(n-i.minIndex);return a&&(h+=c/2),i.top+Math.round(h)},getPixelForTick:function t(e){return this.getPixelForValue(this.ticks[e],e+this.minIndex,null)},getValueForPixel:function t(e){var n=this,i=n.options.offset,a,o=Math.max(n._ticks.length-(i?0:1),1),r=n.isHorizontal(),l=(r?n.width:n.height)/o;return e-=r?n.left:n.top,i&&(e-=l/2),(a=e<=0?0:Math.round(e/l))+n.minIndex},getBasePixel:function t(){return this.bottom}});a.registerScaleType("category",e,t)}},{33:33,34:34}],55:[function(t,e,n){var o=t(26),h=t(46),i=t(34),a=t(35);e.exports=function(t){var e={position:"left",ticks:{callback:a.formatters.linear}},n=t.LinearScaleBase.extend({determineDataLimits:function t(){function r(t){return i?t.xAxisID===l.id:t.yAxisID===l.id}// First Calculate the range
var l=this,s=l.options,u=l.chart,e,n=u.data.datasets,i=l.isHorizontal(),a=0,o=1;l.min=null,l.max=null;var d=s.stacked;if(void 0===d&&h.each(n,function(t,e){if(!d){var n=u.getDatasetMeta(e);u.isDatasetVisible(e)&&r(n)&&void 0!==n.stack&&(d=!0)}}),s.stacked||d){var c={};h.each(n,function(t,e){var i=u.getDatasetMeta(e),n=[i.type,// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
void 0===s.stacked&&void 0===i.stack?e:"",i.stack].join(".");void 0===c[n]&&(c[n]={positiveValues:[],negativeValues:[]});// Store these per type
var a=c[n].positiveValues,o=c[n].negativeValues;u.isDatasetVisible(e)&&r(i)&&h.each(t.data,function(t,e){var n=+l.getRightValue(t);isNaN(n)||i.data[e].hidden||(a[e]=a[e]||0,o[e]=o[e]||0,s.relativePoints?a[e]=100:n<0?o[e]+=n:a[e]+=n)})}),h.each(c,function(t){var e=t.positiveValues.concat(t.negativeValues),n=h.min(e),i=h.max(e);l.min=null===l.min?n:Math.min(l.min,n),l.max=null===l.max?i:Math.max(l.max,i)})}else h.each(n,function(t,e){var i=u.getDatasetMeta(e);u.isDatasetVisible(e)&&r(i)&&h.each(t.data,function(t,e){var n=+l.getRightValue(t);isNaN(n)||i.data[e].hidden||(null===l.min?l.min=n:n<l.min&&(l.min=n),null===l.max?l.max=n:n>l.max&&(l.max=n))})});l.min=isFinite(l.min)&&!isNaN(l.min)?l.min:0,l.max=isFinite(l.max)&&!isNaN(l.max)?l.max:1,// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
this.handleTickRangeOptions()},getTickLimit:function t(){var e,n=this,i=n.options.ticks;if(n.isHorizontal())e=Math.min(i.maxTicksLimit?i.maxTicksLimit:11,Math.ceil(n.width/50));else{
// The factor of 2 used to scale the font size has been experimentally determined.
var a=h.valueOrDefault(i.fontSize,o.global.defaultFontSize);e=Math.min(i.maxTicksLimit?i.maxTicksLimit:11,Math.ceil(n.height/(2*a)))}return e},
// Called after the ticks are built. We need
handleDirectionalChanges:function t(){this.isHorizontal()||
// We are in a vertical orientation. The top value is the highest. So reverse the array
this.ticks.reverse()},getLabelForIndex:function t(e,n){return+this.getRightValue(this.chart.data.datasets[n].data[e])},
// Utils
getPixelForValue:function t(e){
// This must be called after fit has been run so that
// this.left, this.top, this.right, and this.bottom have been defined
var n=this,i=n.start,a=+n.getRightValue(e),o,r=n.end-i;return o=n.isHorizontal()?n.left+n.width/r*(a-i):n.bottom-n.height/r*(a-i)},getValueForPixel:function t(e){var n=this,i=n.isHorizontal(),a=i?n.width:n.height,o=(i?e-n.left:n.bottom-e)/a;return n.start+(n.end-n.start)*o},getPixelForTick:function t(e){return this.getPixelForValue(this.ticksAsNumbers[e])}});i.registerScaleType("linear",n,e)}},{26:26,34:34,35:35,46:46}],56:[function(t,e,n){
/**
       * Generate a set of linear ticks
       * @param generationOptions the options used to generate the ticks
       * @param dataRange the range of the data
       * @returns {Array<Number>} array of tick values
       */
function l(t,e){var n=[],i,a,o;// To get a "nice" value for the tick spacing, we will use the appropriately named
// "nice number" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks
// for details.
if(t.stepSize&&0<t.stepSize)o=t.stepSize;else{var r=c.niceNum(e.max-e.min,!1);o=c.niceNum(r/(t.maxTicks-1),!0),void 0!==(a=t.precision)&&(
// If the user specified a precision, round to that number of decimal places
i=Math.pow(10,a),o=Math.ceil(o*i)/i)}var l=Math.floor(e.min/o)*o,s=Math.ceil(e.max/o)*o;// If min, max and stepSize is set and they make an evenly spaced scale use it.
c.isNullOrUndef(t.min)||c.isNullOrUndef(t.max)||!t.stepSize||
// If very close to our whole number, use it.
c.almostWhole((t.max-t.min)/t.stepSize,o/1e3)&&(l=t.min,s=t.max);var u=(s-l)/o;// If very close to our rounded value, use it.
u=c.almostEquals(u,Math.round(u),o/1e3)?Math.round(u):Math.ceil(u),o<(a=1)&&(a=Math.pow(10,1-Math.floor(c.log10(o))),l=Math.round(l*a)/a,s=Math.round(s*a)/a),n.push(void 0!==t.min?t.min:l);for(var d=1;d<u;++d)n.push(Math.round((l+d*o)*a)/a);return n.push(void 0!==t.max?t.max:s),n}var c=t(46),i=t(33);e.exports=function(t){var e=c.noop;t.LinearScaleBase=i.extend({getRightValue:function t(e){return"string"==typeof e?+e:i.prototype.getRightValue.call(this,e)},handleTickRangeOptions:function t(){var e=this,n,i=e.options.ticks;// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,
// do nothing since that would make the chart weird. If the user really wants a weird chart
// axis, they can manually override it
if(i.beginAtZero){var a=c.sign(e.min),o=c.sign(e.max);a<0&&o<0?
// move the top up to 0
e.max=0:0<a&&0<o&&(
// move the bottom down to 0
e.min=0)}var r=void 0!==i.min||void 0!==i.suggestedMin,l=void 0!==i.max||void 0!==i.suggestedMax;void 0!==i.min?e.min=i.min:void 0!==i.suggestedMin&&(null===e.min?e.min=i.suggestedMin:e.min=Math.min(e.min,i.suggestedMin)),void 0!==i.max?e.max=i.max:void 0!==i.suggestedMax&&(null===e.max?e.max=i.suggestedMax:e.max=Math.max(e.max,i.suggestedMax)),r!==l&&e.min>=e.max&&(r?e.max=e.min+1:e.min=e.max-1),e.min===e.max&&(e.max++,i.beginAtZero||e.min--)},getTickLimit:e,handleDirectionalChanges:e,buildTicks:function t(){var e=this,n,i=e.options.ticks,a=e.getTickLimit(),o={maxTicks:a=Math.max(2,a),min:i.min,max:i.max,precision:i.precision,stepSize:c.valueOrDefault(i.fixedStepSize,i.stepSize)},r=e.ticks=l(o,e);e.handleDirectionalChanges(),// At this point, we need to update our max and min given the tick values since we have expanded the
// range of the scale
e.max=c.max(r),e.min=c.min(r),i.reverse?(r.reverse(),e.start=e.max,e.end=e.min):(e.start=e.min,e.end=e.max)},convertTicksToLabels:function t(){var e=this;e.ticksAsNumbers=e.ticks.slice(),e.zeroLineIndex=e.ticks.indexOf(0),i.prototype.convertTicksToLabels.call(e)}})}},{33:33,46:46}],57:[function(t,e,n){
/**
       * Generate a set of logarithmic ticks
       * @param generationOptions the options used to generate the ticks
       * @param dataRange the range of the data
       * @returns {Array<Number>} array of tick values
       */
function l(t,e){var n=[],i=f.valueOrDefault,a=i(t.min,Math.pow(10,Math.floor(f.log10(e.min)))),o=Math.floor(f.log10(e.max)),r=Math.ceil(e.max/Math.pow(10,o)),l,s;0===a?(l=Math.floor(f.log10(e.minNotZero)),s=Math.floor(e.minNotZero/Math.pow(10,l)),n.push(a),a=s*Math.pow(10,l)):(l=Math.floor(f.log10(a)),s=Math.floor(a/Math.pow(10,l)));for(var u=l<0?Math.pow(10,Math.abs(l)):1;n.push(a),10===++s&&(s=1,u=0<=++l?1:u),a=Math.round(s*Math.pow(10,l)*u)/u,l<o||l===o&&s<r;);var d=i(t.max,a);return n.push(d),n}var f=t(46),i=t(33),a=t(34),o=t(35);e.exports=function(h){var t={position:"left",
// label settings
ticks:{callback:o.formatters.logarithmic}},e=i.extend({determineDataLimits:function t(){function r(t){return a?t.xAxisID===l.id:t.yAxisID===l.id}// Calculate Range
var l=this,n=l.options,s=l.chart,e,i=s.data.datasets,a=l.isHorizontal();l.min=null,l.max=null,l.minNotZero=null;var o=n.stacked;if(void 0===o&&f.each(i,function(t,e){if(!o){var n=s.getDatasetMeta(e);s.isDatasetVisible(e)&&r(n)&&void 0!==n.stack&&(o=!0)}}),n.stacked||o){var u={};f.each(i,function(t,e){var a=s.getDatasetMeta(e),o=[a.type,// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
void 0===n.stacked&&void 0===a.stack?e:"",a.stack].join(".");s.isDatasetVisible(e)&&r(a)&&(void 0===u[o]&&(u[o]=[]),f.each(t.data,function(t,e){var n=u[o],i=+l.getRightValue(t);// invalid, hidden and negative values are ignored
isNaN(i)||a.data[e].hidden||i<0||(n[e]=n[e]||0,n[e]+=i)}))}),f.each(u,function(t){if(0<t.length){var e=f.min(t),n=f.max(t);l.min=null===l.min?e:Math.min(l.min,e),l.max=null===l.max?n:Math.max(l.max,n)}})}else f.each(i,function(t,e){var i=s.getDatasetMeta(e);s.isDatasetVisible(e)&&r(i)&&f.each(t.data,function(t,e){var n=+l.getRightValue(t);// invalid, hidden and negative values are ignored
isNaN(n)||i.data[e].hidden||n<0||(null===l.min?l.min=n:n<l.min&&(l.min=n),null===l.max?l.max=n:n>l.max&&(l.max=n),0!==n&&(null===l.minNotZero||n<l.minNotZero)&&(l.minNotZero=n))})});// Common base implementation to handle ticks.min, ticks.max
this.handleTickRangeOptions()},handleTickRangeOptions:function t(){var e=this,n,i=e.options.ticks,a=f.valueOrDefault,o=1,r=10;e.min=a(i.min,e.min),e.max=a(i.max,e.max),e.min===e.max&&(0!==e.min&&null!==e.min?(e.min=Math.pow(10,Math.floor(f.log10(e.min))-1),e.max=Math.pow(10,Math.floor(f.log10(e.max))+1)):(e.min=1,e.max=10)),null===e.min&&(e.min=Math.pow(10,Math.floor(f.log10(e.max))-1)),null===e.max&&(e.max=0!==e.min?Math.pow(10,Math.floor(f.log10(e.min))+1):10),null===e.minNotZero&&(0<e.min?e.minNotZero=e.min:e.max<1?e.minNotZero=Math.pow(10,Math.floor(f.log10(e.max))):e.minNotZero=1)},buildTicks:function t(){var e=this,n,i=e.options.ticks,a=!e.isHorizontal(),o={min:i.min,max:i.max},r=e.ticks=l(o,e);// At this point, we need to update our max and min given the tick values since we have expanded the
// range of the scale
e.max=f.max(r),e.min=f.min(r),i.reverse?(a=!a,e.start=e.max,e.end=e.min):(e.start=e.min,e.end=e.max),a&&r.reverse()},convertTicksToLabels:function t(){this.tickValues=this.ticks.slice(),i.prototype.convertTicksToLabels.call(this)},
// Get the correct tooltip label
getLabelForIndex:function t(e,n){return+this.getRightValue(this.chart.data.datasets[n].data[e])},getPixelForTick:function t(e){return this.getPixelForValue(this.tickValues[e])},
/**
           * Returns the value of the first tick.
           * @param {Number} value - The minimum not zero value.
           * @return {Number} The first tick value.
           * @private
           */
_getFirstTickValue:function t(e){var n=Math.floor(f.log10(e)),i;return Math.floor(e/Math.pow(10,n))*Math.pow(10,n)},getPixelForValue:function t(e){var n=this,i=n.options.ticks.reverse,a=f.log10,o=n._getFirstTickValue(n.minNotZero),r=0,l,s,u,d,c;return e=+n.getRightValue(e),c=i?(u=n.end,d=n.start,-1):(u=n.start,d=n.end,1),s=n.isHorizontal()?(l=n.width,i?n.right:n.left):(l=n.height,c*=-1,i?n.top:n.bottom),e!==u&&(0===u&&(
// include zero tick
l-=r=f.getValueOrDefault(n.options.ticks.fontSize,h.defaults.global.defaultFontSize),u=o),0!==e&&(r+=l/(a(d)-a(u))*(a(e)-a(u))),s+=c*r),s},getValueForPixel:function t(e){var n=this,i=n.options.ticks.reverse,a=f.log10,o=n._getFirstTickValue(n.minNotZero),r,l,s,u;if(s=i?(l=n.end,n.start):(l=n.start,n.end),(u=n.isHorizontal()?(r=n.width,i?n.right-e:e-n.left):(r=n.height,i?e-n.top:n.bottom-e))!==l){if(0===l){
// include zero tick
var d=f.getValueOrDefault(n.options.ticks.fontSize,h.defaults.global.defaultFontSize);u-=d,r-=d,l=o}u*=a(s)-a(l),u/=r,u=Math.pow(10,a(l)+u)}return u}});a.registerScaleType("logarithmic",e,t)}},{33:33,34:34,35:35,46:46}],58:[function(t,e,n){var r=t(26),w=t(46),l=t(34),s=t(35);e.exports=function(n){function f(t){var e=t.options;return e.angleLines.display||e.pointLabels.display?t.chart.data.labels.length:0}function g(t){var e=t.options.pointLabels,n=w.valueOrDefault(e.fontSize,k.defaultFontSize),i=w.valueOrDefault(e.fontStyle,k.defaultFontStyle),a=w.valueOrDefault(e.fontFamily,k.defaultFontFamily),o;return{size:n,style:i,family:a,font:w.fontString(n,i,a)}}function p(t,e,n){return w.isArray(n)?{w:w.longestText(t,t.font,n),h:n.length*e+1.5*(n.length-1)*e}:{w:t.measureText(n).width,h:e}}function m(t,e,n,i,a){return t===i||t===a?{start:e-n/2,end:e+n/2}:t<i||a<t?{start:e-n-5,end:e}:{start:e,end:e+n+5}}
/**
         * Helper function to fit a radial linear scale with point labels
         */function e(t){
/*
           * Right, this is really confusing and there is a lot of maths going on here
           * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9
           *
           * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif
           *
           * Solution:
           *
           * We assume the radius of the polygon is half the size of the canvas at first
           * at each index we check if the text overlaps.
           *
           * Where it does, we store that angle and that index.
           *
           * After finding the largest index and angle we calculate how much we need to remove
           * from the shape radius to move the point inwards by that x.
           *
           * We average the left and right distances to get the maximum shape radius that can fit in the box
           * along with labels.
           *
           * Once we have that, we can find the centre point for the chart, by taking the x text protrusion
           * on each side, removing that from the size, halving it and adding the left x protrusion width.
           *
           * This will mean we have a shape fitted to the canvas, as large as it can be with the labels
           * and position it in the most space efficient manner
           *
           * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif
           */
var e=g(t),n=Math.min(t.height/2,t.width/2),i={r:t.width,l:0,t:t.height,b:0},a={},o,r,l;// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.
// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points
t.ctx.font=e.font,t._pointLabelSizes=[];var s=f(t);for(o=0;o<s;o++){l=t.getPointPosition(o,n),r=p(t.ctx,e.size,t.pointLabels[o]||""),t._pointLabelSizes[o]=r;// Add quarter circle to make degree 0 mean top of circle
var u=t.getIndexAngle(o),d=w.toDegrees(u)%360,c=m(d,l.x,r.w,0,180),h=m(d,l.y,r.h,90,270);c.start<i.l&&(i.l=c.start,a.l=u),c.end>i.r&&(i.r=c.end,a.r=u),h.start<i.t&&(i.t=h.start,a.t=u),h.end>i.b&&(i.b=h.end,a.b=u)}t.setReductions(n,i,a)}
/**
         * Helper function to fit a radial linear scale with no point labels
         */function i(t){var e=Math.min(t.height/2,t.width/2);t.drawingArea=Math.round(e),t.setCenterPoint(0,0,0,0)}function v(t){return 0===t||180===t?"center":t<180?"left":"right"}function b(t,e,n,i){if(w.isArray(e))for(var a=n.y,o=1.5*i,r=0;r<e.length;++r)t.fillText(e[r],n.x,a),a+=o;else t.fillText(e,n.x,n.y)}function x(t,e,n){90===t||270===t?n.y-=e.h/2:(270<t||t<90)&&(n.y-=e.h)}function a(t){var e=t.ctx,n=t.options,i=n.angleLines,a=n.pointLabels;e.lineWidth=i.lineWidth,e.strokeStyle=i.color;var o=t.getDistanceFromCenterForValue(n.ticks.reverse?t.min:t.max),r=g(t);// Point Label Font
e.textBaseline="top";for(var l=f(t)-1;0<=l;l--){if(i.display){var s=t.getPointPosition(l,o);e.beginPath(),e.moveTo(t.xCenter,t.yCenter),e.lineTo(s.x,s.y),e.stroke(),e.closePath()}if(a.display){
// Extra 3px out for some label spacing
var u=t.getPointPosition(l,o+5),d=w.valueAtIndexOrDefault(a.fontColor,l,k.defaultFontColor);// Keep this in loop since we may support array properties here
e.font=r.font,e.fillStyle=d;var c=t.getIndexAngle(l),h=w.toDegrees(c);e.textAlign=v(h),x(h,t._pointLabelSizes[l],u),b(e,t.pointLabels[l]||"",u,r.size)}}}function y(t,e,n,i){var a=t.ctx;if(a.strokeStyle=w.valueAtIndexOrDefault(e.color,i-1),a.lineWidth=w.valueAtIndexOrDefault(e.lineWidth,i-1),t.options.gridLines.circular)
// Draw circular arcs between the points
a.beginPath(),a.arc(t.xCenter,t.yCenter,n,0,2*Math.PI),a.closePath(),a.stroke();else{
// Draw straight lines connecting each index
var o=f(t);if(0===o)return;a.beginPath();var r=t.getPointPosition(0,n);a.moveTo(r.x,r.y);for(var l=1;l<o;l++)r=t.getPointPosition(l,n),a.lineTo(r.x,r.y);a.closePath(),a.stroke()}}function u(t){return w.isNumber(t)?t:0}var k=r.global,t={display:!0,
// Boolean - Whether to animate scaling the chart from the centre
animate:!0,position:"chartArea",angleLines:{display:!0,color:"rgba(0, 0, 0, 0.1)",lineWidth:1},gridLines:{circular:!1},
// label settings
ticks:{
// Boolean - Show a backdrop to the scale label
showLabelBackdrop:!0,
// String - The colour of the label backdrop
backdropColor:"rgba(255,255,255,0.75)",
// Number - The backdrop padding above & below the label in pixels
backdropPaddingY:2,
// Number - The backdrop padding to the side of the label in pixels
backdropPaddingX:2,callback:s.formatters.linear},pointLabels:{
// Boolean - if true, show point labels
display:!0,
// Number - Point label font size in pixels
fontSize:10,
// Function - Used to convert point labels
callback:function t(e){return e}}},o=n.LinearScaleBase.extend({setDimensions:function t(){var e=this,n=e.options,i=n.ticks;// Set the unconstrained dimension before label rotation
e.width=e.maxWidth,e.height=e.maxHeight,e.xCenter=Math.round(e.width/2),e.yCenter=Math.round(e.height/2);var a=w.min([e.height,e.width]),o=w.valueOrDefault(i.fontSize,k.defaultFontSize);e.drawingArea=n.display?a/2-(o/2+i.backdropPaddingY):a/2},determineDataLimits:function t(){var a=this,n=a.chart,o=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY;w.each(n.data.datasets,function(t,e){if(n.isDatasetVisible(e)){var i=n.getDatasetMeta(e);w.each(t.data,function(t,e){var n=+a.getRightValue(t);isNaN(n)||i.data[e].hidden||(o=Math.min(n,o),r=Math.max(n,r))})}}),a.min=o===Number.POSITIVE_INFINITY?0:o,a.max=r===Number.NEGATIVE_INFINITY?0:r,// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
a.handleTickRangeOptions()},getTickLimit:function t(){var e=this.options.ticks,n=w.valueOrDefault(e.fontSize,k.defaultFontSize);return Math.min(e.maxTicksLimit?e.maxTicksLimit:11,Math.ceil(this.drawingArea/(1.5*n)))},convertTicksToLabels:function t(){var e=this;n.LinearScaleBase.prototype.convertTicksToLabels.call(e),// Point labels
e.pointLabels=e.chart.data.labels.map(e.options.pointLabels.callback,e)},getLabelForIndex:function t(e,n){return+this.getRightValue(this.chart.data.datasets[n].data[e])},fit:function t(){this.options.pointLabels.display?e(this):i(this)},
/**
           * Set radius reductions and determine new radius and center point
           * @private
           */
setReductions:function t(e,n,i){var a=this,o=n.l/Math.sin(i.l),r=Math.max(n.r-a.width,0)/Math.sin(i.r),l=-n.t/Math.cos(i.t),s=-Math.max(n.b-a.height,0)/Math.cos(i.b);o=u(o),r=u(r),l=u(l),s=u(s),a.drawingArea=Math.min(Math.round(e-(o+r)/2),Math.round(e-(l+s)/2)),a.setCenterPoint(o,r,l,s)},setCenterPoint:function t(e,n,i,a){var o=this,r=o.width-n-o.drawingArea,l=e+o.drawingArea,s=i+o.drawingArea,u=o.height-a-o.drawingArea;o.xCenter=Math.round((l+r)/2+o.left),o.yCenter=Math.round((s+u)/2+o.top)},getIndexAngle:function t(e){var n,i,a;// Start from the top instead of right, so remove a quarter of the circle
return e*(2*Math.PI/f(this))+(this.chart.options&&this.chart.options.startAngle?this.chart.options.startAngle:0)*Math.PI*2/360},getDistanceFromCenterForValue:function t(e){var n=this;if(null===e)return 0;// null always in center
// Take into account half font size + the yPadding of the top value
var i=n.drawingArea/(n.max-n.min);return n.options.ticks.reverse?(n.max-e)*i:(e-n.min)*i},getPointPosition:function t(e,n){var i=this,a=i.getIndexAngle(e)-Math.PI/2;return{x:Math.round(Math.cos(a)*n)+i.xCenter,y:Math.round(Math.sin(a)*n)+i.yCenter}},getPointPositionForValue:function t(e,n){return this.getPointPosition(e,this.getDistanceFromCenterForValue(n))},getBasePosition:function t(){var e=this,n=e.min,i=e.max;return e.getPointPositionForValue(0,e.beginAtZero?0:n<0&&i<0?i:0<n&&0<i?n:0)},draw:function t(){var o=this,e=o.options,r=e.gridLines,l=e.ticks,s=w.valueOrDefault;if(e.display){var u=o.ctx,d=this.getIndexAngle(0),c=s(l.fontSize,k.defaultFontSize),n=s(l.fontStyle,k.defaultFontStyle),i=s(l.fontFamily,k.defaultFontFamily),h=w.fontString(c,n,i);w.each(o.ticks,function(t,e){
// Don't draw a centre value (if it is minimum)
if(0<e||l.reverse){var n=o.getDistanceFromCenterForValue(o.ticksAsNumbers[e]);// Draw circular lines around the scale
if(r.display&&0!==e&&y(o,r,n,e),l.display){var i=s(l.fontColor,k.defaultFontColor);if(u.font=h,u.save(),u.translate(o.xCenter,o.yCenter),u.rotate(d),l.showLabelBackdrop){var a=u.measureText(t).width;u.fillStyle=l.backdropColor,u.fillRect(-a/2-l.backdropPaddingX,-n-c/2-l.backdropPaddingY,a+2*l.backdropPaddingX,c+2*l.backdropPaddingY)}u.textAlign="center",u.textBaseline="middle",u.fillStyle=i,u.fillText(t,0,-n),u.restore()}}}),(e.angleLines.display||e.pointLabels.display)&&a(o)}}});l.registerScaleType("radialLinear",o,t)}},{26:26,34:34,35:35,46:46}],59:[function(t,e,n){function m(t,e){return t-e}function v(t){var e={},n=[],i,a,o;for(i=0,a=t.length;i<a;++i)e[o=t[i]]||(e[o]=!0,n.push(o));return n}
/**
       * Returns an array of {time, pos} objects used to interpolate a specific `time` or position
       * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is
       * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other
       * extremity (left + width or top + height). Note that it would be more optimized to directly
       * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need
       * to create the lookup table. The table ALWAYS contains at least two items: min and max.
       *
       * @param {Number[]} timestamps - timestamps sorted from lowest to highest.
       * @param {String} distribution - If 'linear', timestamps will be spread linearly along the min
       * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.
       * If 'series', timestamps will be positioned at the same distance from each other. In this
       * case, only timestamps that break the time linearity are registered, meaning that in the
       * best case, all timestamps are linear, the table contains only min and max.
       */function c(t,e,n,i){if("linear"===i||!t.length)return[{time:e,pos:0},{time:n,pos:1}];var a=[],o=[e],r,l,s,u,d;for(r=0,l=t.length;r<l;++r)e<(u=t[r])&&u<n&&o.push(u);for(o.push(n),r=0,l=o.length;r<l;++r)d=o[r+1],s=o[r-1],u=o[r],// only add points that breaks the scale linearity
void 0!==s&&void 0!==d&&Math.round((d+s)/2)===u||a.push({time:u,pos:r/(l-1)});return a}// @see adapted from http://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/
function d(t,e,n){for(var i=0,a=t.length-1,o,r,l;0<=i&&i<=a;){if(r=t[(o=i+a>>1)-1]||null,l=t[o],!r)
// given value is outside table (before first item)
return{lo:null,hi:l};if(l[e]<n)i=o+1;else{if(!(r[e]>n))return{lo:r,hi:l};a=o-1}}// given value is outside table (after last item)
return{lo:l,hi:null}}
/**
       * Linearly interpolates the given source `value` using the table items `skey` values and
       * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')
       * returns the position for a timestamp equal to 42. If value is out of bounds, values at
       * index [0, 1] or [n - 1, n] are used for the interpolation.
       */function u(t,e,n,i){var a=d(t,e,n),o=a.lo?a.hi?a.lo:t[t.length-2]:t[0],r=a.lo?a.hi?a.hi:t[t.length-1]:t[1],l=r[e]-o[e],s=l?(n-o[e])/l:0,u=(r[i]-o[i])*s;// Note: the lookup table ALWAYS contains at least 2 items (min and max)
return o[i]+u}
/**
       * Convert the given value to a moment object using the given time options.
       * @see http://momentjs.com/docs/#/parsing/
       */function s(t,e){var n=e.parser,i=e.parser||e.format;return"function"==typeof n?n(t):"string"==typeof t&&"string"==typeof i?M(t,i):(t instanceof M||(t=M(t)),t.isValid()?t:// Labels are in an incompatible moment format and no `parser` has been provided.
// The user might still use the deprecated `format` option to convert his inputs.
"function"==typeof i?i(t):t)}function b(t,e){if(S.isNullOrUndef(t))return null;var n=e.options.time,i=s(e.getRightValue(t),n);return i.isValid()?(n.round&&i.startOf(n.round),i.valueOf()):null}
/**
       * Returns the number of unit to skip to be able to display up to `capacity` number of ticks
       * in `unit` for the given `min` / `max` range and respecting the interval steps constraints.
       */function p(t,e,n,i){var a=e-t,o=P[n],r=o.size,l=o.steps,s,u,d;if(!l)return Math.ceil(a/(i*r));for(s=0,u=l.length;s<u&&(d=l[s],!(Math.ceil(a/(r*d))<=i));++s);return d}
/**
       * Figures out what unit results in an appropriate number of auto-generated ticks
       */function x(t,e,n,i){var a=I.length,o,r,l;for(o=I.indexOf(t);o<a-1;++o)if(l=(r=P[I[o]]).steps?r.steps[r.steps.length-1]:D,r.common&&Math.ceil((n-e)/(l*r.size))<=i)return I[o];return I[a-1]}
/**
       * Figures out what unit to format a set of ticks with
       */function h(t,e,n,i){var a=M.duration(M(i).diff(M(n))),o,r,l;for(r=I.length-1;r>=I.indexOf(e);r--)if(l=I[r],P[l].common&&a.as(l)>=t.length)return l;return I[e?I.indexOf(e):0]}function y(t){for(var e=I.indexOf(t)+1,n=I.length;e<n;++e)if(P[I[e]].common)return I[e]}
/**
       * Generates a maximum of `capacity` timestamps between min and max, rounded to the
       * `minor` unit, aligned on the `major` unit and using the given scale time `options`.
       * Important: this method can return ticks outside the min and max range, it's the
       * responsibility of the calling code to clamp values if needed.
       */function f(t,e,n,i){var a=i.time,o=a.unit||x(a.minUnit,t,e,n),r=y(o),l=S.valueOrDefault(a.stepSize,a.unitStepSize),s="week"===o&&a.isoWeekday,u=i.ticks.major.enabled,d=P[o],c=M(t),h=M(e),f=[],g;for(l||(l=p(t,e,o,n)),// For 'week' unit, handle the first day of week option
s&&(c=c.isoWeekday(s),h=h.isoWeekday(s)),// Align first/last ticks on unit
c=c.startOf(s?"day":o),// Make sure that the last tick include max
(h=h.startOf(s?"day":o))<e&&h.add(1,o),g=M(c),u&&r&&!s&&!a.round&&(
// Align the first tick on the previous `minor` unit aligned on the `major` unit:
// we first aligned time on the previous `major` unit then add the number of full
// stepSize there is between first and the previous major time.
g.startOf(r),g.add(~~((c-g)/(d.size*l))*l,o));g<h;g.add(l,o))f.push(+g);return f.push(+g),f}
/**
       * Returns the right and left offsets from edges in the form of {left, right}.
       * Offsets are added when the `offset` option is true.
       */function g(t,e,n,i,a){var o=0,r=0,l,s;return a.offset&&e.length&&(a.time.min||(l=1<e.length?e[1]:i,s=e[0],o=(u(t,"time",l,"pos")-u(t,"time",s,"pos"))/2),a.time.max||(l=e[e.length-1],s=1<e.length?e[e.length-2]:n,r=(u(t,"time",l,"pos")-u(t,"time",s,"pos"))/2)),{left:o,right:r}}function k(t,e){var n=[],i,a,o,r;for(i=0,a=t.length;i<a;++i)o=t[i],r=!!e&&o===+M(o).startOf(e),n.push({value:o,major:r});return n}function w(t,e){var n,i,a,o=t.length;// find the label with the most parts (milliseconds, minutes, etc.)
// format all labels with the same level of detail as the most specific label
for(n=0;n<o;n++){if(0!==(i=s(t[n],e)).millisecond())return"MMM D, YYYY h:mm:ss.SSS a";0===i.second()&&0===i.minute()&&0===i.hour()||(a=!0)}return a?"MMM D, YYYY h:mm:ss a":"MMM D, YYYY"}var M=t(1);M="function"==typeof M?M:window.moment;var C=t(26),S=t(46),i=t(33),a=t(34),_=Number.MIN_SAFE_INTEGER||-9007199254740991,D=Number.MAX_SAFE_INTEGER||9007199254740991,P={millisecond:{common:!0,size:1,steps:[1,2,5,10,20,50,100,250,500]},second:{common:!0,size:1e3,steps:[1,2,5,10,15,30]},minute:{common:!0,size:6e4,steps:[1,2,5,10,15,30]},hour:{common:!0,size:36e5,steps:[1,2,3,6,12]},day:{common:!0,size:864e5,steps:[1,2,5]},week:{common:!1,size:6048e5,steps:[1,2,3,4]},month:{common:!0,size:2628e6,steps:[1,2,3]},quarter:{common:!1,size:7884e6,steps:[1,2,3,4]},year:{common:!0,size:3154e7}},I=Object.keys(P);e.exports=function(){var t={position:"bottom",
/**
           * Data distribution along the scale:
           * - 'linear': data are spread according to their time (distances can vary),
           * - 'series': data are spread at the same distance from each other.
           * @see https://github.com/chartjs/Chart.js/pull/4507
           * @since 2.7.0
           */
distribution:"linear",
/**
           * Scale boundary strategy (bypassed by min/max time options)
           * - `data`: make sure data are fully visible, ticks outside are removed
           * - `ticks`: make sure ticks are fully visible, data outside are truncated
           * @see https://github.com/chartjs/Chart.js/pull/4556
           * @since 2.7.0
           */
bounds:"data",time:{parser:!1,
// false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment
format:!1,
// DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/
unit:!1,
// false == automatic or override with week, month, year, etc.
round:!1,
// none, or override with week, month, year, etc.
displayFormat:!1,
// DEPRECATED
isoWeekday:!1,
// override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/
minUnit:"millisecond",
// defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/
displayFormats:{millisecond:"h:mm:ss.SSS a",
// 11:20:01.123 AM,
second:"h:mm:ss a",
// 11:20:01 AM
minute:"h:mm a",
// 11:20 AM
hour:"hA",
// 5PM
day:"MMM D",
// Sep 4
week:"ll",
// Week 46, or maybe "[W]WW - YYYY" ?
month:"MMM YYYY",
// Sept 2015
quarter:"[Q]Q - YYYY",
// Q3
year:"YYYY"}},ticks:{autoSkip:!1,
/**
             * Ticks generation input values:
             * - 'auto': generates "optimal" ticks based on scale size and time options.
             * - 'data': generates ticks from data (including labels from data {t|x|y} objects).
             * - 'labels': generates ticks from user given `data.labels` values ONLY.
             * @see https://github.com/chartjs/Chart.js/pull/4507
             * @since 2.7.0
             */
source:"auto",major:{enabled:!1}}},e=i.extend({initialize:function t(){if(!M)throw new Error("Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com");this.mergeTicksOptions(),i.prototype.initialize.call(this)},update:function t(){var e=this,n=e.options;// DEPRECATIONS: output a message only one time per update
return n.time&&n.time.format&&console.warn("options.time.format is deprecated and replaced by options.time.parser."),i.prototype.update.apply(e,arguments)},
/**
           * Allows data to be referenced via 't' attribute
           */
getRightValue:function t(e){return e&&void 0!==e.t&&(e=e.t),i.prototype.getRightValue.call(this,e)},determineDataLimits:function t(){var e=this,n=e.chart,i=e.options.time,a=i.unit||"day",o=D,r=_,l=[],s=[],u=[],d,c,h,f,g,p;// Convert labels to timestamps
for(d=0,h=n.data.labels.length;d<h;++d)u.push(b(n.data.labels[d],e));// Convert data to timestamps
for(d=0,h=(n.data.datasets||[]).length;d<h;++d)if(n.isDatasetVisible(d))// Let's consider that all data have the same format.
if(g=n.data.datasets[d].data,S.isObject(g[0]))for(s[d]=[],c=0,f=g.length;c<f;++c)p=b(g[c],e),l.push(p),s[d][c]=p;else l.push.apply(l,u),s[d]=u.slice(0);else s[d]=[];u.length&&(
// Sort labels **after** data have been converted
u=v(u).sort(m),o=Math.min(o,u[0]),r=Math.max(r,u[u.length-1])),l.length&&(l=v(l).sort(m),o=Math.min(o,l[0]),r=Math.max(r,l[l.length-1])),o=b(i.min,e)||o,r=b(i.max,e)||r,// In case there is no valid min/max, set limits based on unit time option
o=o===D?+M().startOf(a):o,r=r===_?+M().endOf(a)+1:r,// Make sure that max is strictly higher than min (required by the lookup table)
e.min=Math.min(o,r),e.max=Math.max(o+1,r),// PRIVATE
e._horizontal=e.isHorizontal(),e._table=[],e._timestamps={data:l,datasets:s,labels:u}},buildTicks:function t(){var e=this,n=e.min,i=e.max,a=e.options,o=a.time,r=[],l=[],s,u,d;switch(a.ticks.source){case"data":r=e._timestamps.data;break;case"labels":r=e._timestamps.labels;break;case"auto":default:r=f(n,i,e.getLabelCapacity(n),a)}// Remove ticks outside the min/max range
for("ticks"===a.bounds&&r.length&&(n=r[0],i=r[r.length-1]),// Enforce limits with user min/max options
n=b(o.min,e)||n,i=b(o.max,e)||i,s=0,u=r.length;s<u;++s)n<=(d=r[s])&&d<=i&&l.push(d);return e.min=n,e.max=i,// PRIVATE
e._unit=o.unit||h(l,o.minUnit,e.min,e.max),e._majorUnit=y(e._unit),e._table=c(e._timestamps.data,n,i,a.distribution),e._offsets=g(e._table,l,n,i,a),e._labelFormat=w(e._timestamps.data,o),k(l,e._majorUnit)},getLabelForIndex:function t(e,n){var i=this,a=i.chart.data,o=i.options.time,r=a.labels&&e<a.labels.length?a.labels[e]:"",l=a.datasets[n].data[e];return S.isObject(l)&&(r=i.getRightValue(l)),o.tooltipFormat?s(r,o).format(o.tooltipFormat):"string"==typeof r?r:s(r,o).format(i._labelFormat)},
/**
           * Function to format an individual tick mark
           * @private
           */
tickFormatFunction:function t(e,n,i,a){var o=this,r=o.options,l=e.valueOf(),s=r.time.displayFormats,u=s[o._unit],d=o._majorUnit,c=s[d],h=e.clone().startOf(d).valueOf(),f=r.ticks.major,g=f.enabled&&d&&c&&l===h,p=e.format(a||(g?c:u)),m=g?f:r.ticks.minor,v=S.valueOrDefault(m.callback,m.userCallback);return v?v(p,n,i):p},convertTicksToLabels:function t(e){var n=[],i,a;for(i=0,a=e.length;i<a;++i)n.push(this.tickFormatFunction(M(e[i].value),i,e));return n},
/**
           * @private
           */
getPixelForOffset:function t(e){var n=this,i=n._horizontal?n.width:n.height,a=n._horizontal?n.left:n.top,o=u(n._table,"time",e,"pos");return a+i*(n._offsets.left+o)/(n._offsets.left+1+n._offsets.right)},getPixelForValue:function t(e,n,i){var a=this,o=null;if(void 0!==n&&void 0!==i&&(o=a._timestamps.datasets[i][n]),null===o&&(o=b(e,a)),null!==o)return a.getPixelForOffset(o)},getPixelForTick:function t(e){var n=this.getTicks();return 0<=e&&e<n.length?this.getPixelForOffset(n[e].value):null},getValueForPixel:function t(e){var n=this,i=n._horizontal?n.width:n.height,a=n._horizontal?n.left:n.top,o=(i?(e-a)/i:0)*(n._offsets.left+1+n._offsets.left)-n._offsets.right,r=u(n._table,"pos",o,"time");return M(r)},
/**
           * Crude approximation of what the label width might be
           * @private
           */
getLabelWidth:function t(e){var n=this,i=n.options.ticks,a=n.ctx.measureText(e).width,o=S.toRadians(i.maxRotation),r=Math.cos(o),l=Math.sin(o),s;return a*r+S.valueOrDefault(i.fontSize,C.global.defaultFontSize)*l},
/**
           * @private
           */
getLabelCapacity:function t(e){var n=this,i=n.options.time.displayFormats.millisecond,a=n.tickFormatFunction(M(e),0,[],i),o=n.getLabelWidth(a),r=n.isHorizontal()?n.width:n.height,l=Math.floor(r/o);return 0<l?l:1}});a.registerScaleType("time",e,t)}},{1:1,26:26,33:33,34:34,46:46}]},{},[7])(7)});
//# sourceMappingURL=Chart.min.js.map